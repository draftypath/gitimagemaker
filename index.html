<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>Image Maker Studio</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Create stunning images with Image Maker Studio, a free online editor. Easily manage layers, apply visual effects, add stylish text, and use the AI background remover. Start creating now!">
<link rel="icon" type="image/png" href="favicon.ico">
<link href="https://fonts.googleapis.com/css2?family=VT323&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<style>
/* --- CRITICAL CSS: Inlined for fastest first paint --- */
:root{--bg:#f2efe8;--ink:#2b2b2b;--mid:#c2c2c2;--light:#faf9f5;--light-rgb:250,249,245;--shadow:#7a7a7a;--danger-color:#cc4444;--action-color:#4477cc;--success-color:#55cc55;--bg-rgb:242,239,232;--action-color-rgb:68,119,204;transition:--bg .3s, --ink .3s, --mid .3s, --light .3s, --shadow .3s, --action-color .3s, --danger-color .3s, --success-color .3s}
html{box-sizing:border-box}*,:before,:after{box-sizing:inherit}
body{font-family:'VT323',monospace;background-color:color-mix(in srgb,var(--bg) 15%,#000);color:var(--ink);display:flex;flex-direction:column;align-items:center;padding:10px;margin:0;height:100vh;overflow:hidden;transition:background-color .3s,color .3s}
#loading-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background-color:var(--bg);color:var(--ink);display:flex;align-items:center;justify-content:center;z-index:9999;transition:opacity .5s ease-in-out}
#loading-overlay h1{font-family:'VT323',monospace;font-size:2.5rem;text-shadow:1px 1px 0 var(--shadow)}
#loading-overlay h1::after{content:'.';display:inline-block;width:3ch;text-align:left;animation:ellipsis 1.4s infinite}
@keyframes ellipsis{0%{content:'.'}33%{content:'..'}66%{content:'...'}}

/* === UI & LAYOUT STYLES === */
.window{position:relative;background:var(--light);border:2px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);width:100%;max-width:1600px;margin:0 auto;height:calc(100vh - 20px);display:flex;flex-direction:column;overflow:hidden;transition:background-color .3s,border-color .3s,box-shadow .3s;border-radius:3px}
.titlebar{height:28px;background:var(--mid);display:flex;align-items:center;justify-content:space-between;padding:0 8px;border-bottom:2px solid var(--ink);font-size:20px;flex-shrink:0;cursor:default;position:relative;transition:background-color .3s,border-color .3s}
.titlebar-controls{display:flex;align-items:center;gap:8px}
.controls-fake{display:flex;gap:4px}.btn-square{width:16px;height:16px;background:var(--light);border:2px solid var(--ink)}
.controls-fake .btn-square:first-child{background-color:var(--success-color)}
.controls-fake .btn-square:last-child{background-color:var(--danger-color)}
#erase-tool-btn,#shortcuts-btn,#text-btn,#toggle-view-btn,#visuals-btn,#ai-tools-btn{font-family:inherit;font-size:1.1rem;background:var(--light);border:1px solid var(--ink);padding:0 8px;cursor:pointer;color:var(--ink);border-radius:3px;box-shadow:2px 2px 0 var(--shadow);transition:transform .15s ease-out,box-shadow .15s ease-out}
#erase-tool-btn:hover,#shortcuts-btn:hover,#text-btn:hover,#toggle-view-btn:hover,#visuals-btn:hover,#ai-tools-btn:hover{transform:translate(1px,1px);box-shadow:1px 1px 0 var(--shadow)}
#erase-tool-btn:active,#shortcuts-btn:active,#text-btn:active,#toggle-view-btn:active,#visuals-btn:active,#ai-tools-btn:active{transform:translate(2px,2px);box-shadow:none}

/* New style for "pressed-in" active buttons */
#erase-tool-btn.btn-active, #text-btn.btn-active, #visuals-btn.btn-active, #ai-tools-btn.btn-active {
    transform: translate(2px, 2px);
    box-shadow: none;
    background-color: var(--action-color);
    color: var(--light);
}
body[data-theme-name="classic light"] #erase-tool-btn.btn-active,
body[data-theme-name="classic light"] #text-btn.btn-active,
body[data-theme-name="classic light"] #visuals-btn.btn-active,
body[data-theme-name="classic light"] #ai-tools-btn.btn-active {
    color: var(--bg);
}

/* Custom Midnight Theme Overrides */
.mg-btn.generate {
    background-color: var(--success-color);
    color: var(--light); /* Ensure text is readable */
}

body[data-theme-name="Midnight"] #canvas-panel {
    border-color: #054e3c;
}

#toggle-view-btn{padding:0 4px;font-size:18px}
main#studio-container{display:grid;grid-template-columns:320px 1fr;grid-template-rows:minmax(0,1fr);gap:1.5rem;padding:1.5rem;flex-grow:1;min-height:0}
#canvas-panel{display:flex;align-items:center;justify-content:center;border:2px solid var(--ink);background-color:var(--mid);position:relative;min-height:0;transition:background-color .5s ease-in-out;overflow:hidden}

/* === PANEL SYSTEM STYLES (REFINED) === */
#controls-panel {
    position: relative;
    overflow: hidden;
}
.control-panel {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    transform: translateX(-101%);
    pointer-events: none;
    opacity: 0;
    transition: transform 0.49s ease-in-out, opacity 0.35s ease-in-out;
    background-color: var(--light);
    border: 2px solid var(--ink);
    border-radius: 0 6px 6px 0;
    box-shadow: 4px 0 12px rgba(0,0,0,0.15);
    padding: 1rem;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 1.25rem;
    overflow-y: auto;
}

.control-panel.active {
    transform: translateX(0);
    opacity: 1;
    pointer-events: auto;
}
.panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: .75rem;
    border-bottom: 2px solid var(--ink);
    padding-bottom: .5rem;
    flex-shrink: 0;
    margin: 0;
    padding-left: 0;
    padding-right: 0;
    margin-bottom: 0;
}

.panel-header h5 {
    margin: 0;
    font-size: 1.5rem;
}

.panel-header .back-button {
    order: 2;
    font-family: inherit;
    font-size: 1.3rem;
    background: var(--light);
    border: 2px solid var(--ink);
    color: var(--ink);
    cursor: pointer;
    width: 34px;
    height: 34px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    box-shadow: 2px 2px 0 var(--ink);
    transition: transform .15s ease-out, box-shadow .15s ease-out;
}
.panel-header .back-button:hover {
    transform: translate(1px, 1px);
    box-shadow: 1px 1px 0 var(--ink);
}
.panel-header .back-button:active {
    transform: translate(2px, 2px);
    box-shadow: none;
}
/* --- FINAL MODIFICATION: TIGHTER SPACING --- */
#default-panel {
    position: static;
    transform: none;
    opacity: 1;
    pointer-events: auto;
    background-color: transparent;
    padding: 0;
    gap: 1rem; /* Reduced from 1.5rem */
    border: none;
    box-shadow: none;
    border-radius: 0;
}
#default-panel fieldset {
    background: transparent;
    border: 2px solid var(--ink);
    padding: .8rem;
    padding-top: 1.25rem;
    margin: 0;
    text-align: left;
    transition: background-color .3s, border-color .3s;
    border-radius: 6px;
}
#default-panel legend {
    font-size: 1.25rem;
    font-weight: 400;
    padding: 0 .5rem;
    margin-left: .5rem;
    color: var(--ink);
    transition: color .3s;
}

/* === VISUALS PANEL TABS === */
.visuals-main-tab-btn {
    font-family: inherit;
    font-size: 1rem;
    background: var(--light);
    border: 2px solid var(--ink);
    padding: 8px 12px;
    cursor: pointer;
    color: var(--ink);
    transition: .2s all ease-out;
    box-shadow: 2px 2px 0 var(--ink);
    flex-grow: 1;
    text-align: center;
    border-radius: 4px;
}
.visuals-main-tab-btn:hover {
    transform: translate(1px, 1px);
    box-shadow: 1px 1px 0 var(--ink);
}
.visuals-main-tab-btn.active {
    background-color: var(--ink);
    color: var(--light);
    transform: translate(2px, 2px);
    box-shadow: none;
}
body[data-theme-name="classic light"] .visuals-main-tab-btn.active {
    color: var(--bg);
}
#visuals-tabs {
    display: flex;
    gap: .75rem;
    margin-bottom: .8rem;
}

/* === SLIDER STYLING === */
#controls-panel input[type=range] {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 6px;
    background: var(--mid);
    outline: none;
    cursor: pointer;
    border-radius: 3px;
    background: linear-gradient(to right, var(--ink) 0%, var(--ink) 50%, var(--mid) 50%, var(--mid) 100%);
}
#controls-panel input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    background: var(--light);
    border-radius: 50%;
    border: 2px solid var(--ink);
    box-shadow: none;
}
#controls-panel input[type=range]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: var(--light);
    border-radius: 50%;
    border: 2px solid var(--ink);
    box-shadow: none;
    cursor: pointer;
}

/* --- DARK THEME READABILITY FIXES --- */
body[data-theme-is-dark="true"] #canvas-placeholder { color: var(--ink); border-color: var(--mid); }
body[data-theme-is-dark="true"] #canvas-placeholder:hover { color: var(--action-color); border-color: var(--action-color); }
body[data-theme-is-dark="true"] #mg-asset-picker-wrapper { color: var(--ink); }
body[data-theme-is-dark="true"] #mg-asset-drop-zone { color: var(--mid); border-color: var(--mid); }
body[data-theme-is-dark="true"] #mg-asset-drop-zone:hover { color: var(--ink); border-color: var(--ink); }

/* === FONT PREVIEW MODAL STYLES === */
#font-preview-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 1rem;
    align-content: flex-start;
}
.font-preview-item {
    background-color: var(--bg);
    border: 2px solid var(--mid);
    border-radius: 4px;
    padding: 1rem;
    cursor: pointer;
    text-align: center;
    min-height: 100px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease-out;
    color: var(--ink);
    font-size: 1.5rem;
    line-height: 1.2;
    overflow-wrap: break-word;
    word-break: break-word;
}
.font-preview-item:hover {
    border-color: var(--action-color);
    background-color: color-mix(in srgb, var(--bg) 90%, var(--action-color) 10%);
    transform: translateY(-2px);
    box-shadow: 2px 2px 0 var(--shadow);
}

/* === SHARED & MIGRATED STYLES (REFINED) === */
#shortcuts-dropdown{position:absolute;top:28px;background:rgba(var(--bg-rgb), 0.4);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);border:2px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);padding:.5rem 1rem;z-index:100;width:250px;border-radius:4px;right:8px;opacity:0;transform:translateY(-10px);transition:opacity .2s ease-out,transform .2s ease-out;pointer-events:none;display:none}
#shortcuts-dropdown.visible{opacity:1;transform:translateY(0);pointer-events:auto;display:block}
#shortcuts-dropdown h5{margin:0 0 .5rem;font-size:1.25rem;text-align:center}
#shortcuts-dropdown ul{margin:0;padding:0;list-style:none;font-size:1rem}
#shortcuts-dropdown li{display:flex;justify-content:space-between;padding:2px 0}
#shortcuts-dropdown li kbd{font-family:inherit;border:2px solid var(--ink);padding:0 4px;background:var(--bg);transition:background-color .3s,border-color .3s,color .3s}
h6{font-size:1.15rem;font-weight:700;text-align:left;margin-top:1.25rem;margin-bottom:.5rem;border-bottom:2px solid var(--ink);padding-bottom:4px}
.control-panel h6:first-of-type { margin-top: 0; }
.compact-slider-row{display:flex;align-items:center;gap:.75rem;margin-bottom:.5rem}
.compact-slider-row label{flex-shrink:0;margin:0}
.compact-slider-row input[type=range]{width:100%}
.compact-color-row{display:flex;align-items:flex-start;gap:.75rem}
.compact-color-row .slider-container{flex:1}
.compact-color-row input[type=color]{width:100%;height:25px;padding:0;border:1px solid var(--ink)}
.compact-color-row label{margin-bottom:2px}
.hidden{display:none!important}
.disabled{opacity:.5;pointer-events:none}
.slider-container{margin-bottom:0.75rem;}
.slider-container label { display: block; margin-bottom: 0.25rem; }
.mg-btn{font-family:inherit;font-size:18px;background:color-mix(in srgb,var(--light) 95%,var(--ink) 5%);border:2px solid var(--ink);padding:8px 16px;margin:4px;cursor:pointer;text-decoration:none;color:var(--ink);transition:.2s all;box-shadow:2px 2px 0 var(--shadow);width:calc(100% - 8px);white-space:nowrap;border-radius:3px}
.mg-btn:hover{transform:translate(1px,1px);box-shadow:1px 1px 0 var(--shadow)}
.mg-btn:active{transform:translate(2px,2px);box-shadow:none}
.mg-btn.disabled,.mg-btn:disabled{opacity:.5;pointer-events:none;box-shadow:none;transform:none}
.mg-btn.active{background-color:var(--action-color);color:var(--light);box-shadow:none;transform:translate(2px,2px)}
.eraser-mode-selector{display:flex;gap:.5rem}
#text-layer-manager{display:flex;gap:.5rem;align-items:center;padding-bottom:.5rem;margin-bottom:.5rem;border-bottom:2px solid var(--mid)}
.effects-checkbox{display:flex;align-items:center;margin-top:.5rem}
.effects-controls{padding-left:1.5rem;border-left:2px solid var(--mid);margin-left:.5rem;}
footer{height:28px;padding:0 8px;display:flex;justify-content:space-between;align-items:center;font-size:.9rem;flex-shrink:0;gap:1rem;background-color:var(--light);color:var(--ink);transition:background-color .3s,color .3s;border-top:2px solid var(--ink)}
.footer-links,.footer-right{display:flex;flex-wrap:wrap;gap:1.5rem;align-items:center}
footer a{color:var(--ink);text-decoration:none;transition:opacity .2s,color .3s;opacity:.7}
footer a:hover{opacity:1}
footer a i{margin-right:.5em}
.mg-overlay-base{position:fixed;top:0;left:0;width:100%;height:100%;z-index:1000;display:flex;align-items:center;justify-content:center;opacity:0;visibility:hidden;pointer-events:none;transition:opacity .3s,visibility 0s .3s;background:rgba(10,10,10,.25)}
.mg-overlay-base.visible{opacity:1;visibility:visible;pointer-events:auto;transition:opacity .3s,visibility 0s 0s}
#canvas-placeholder{width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center}
.placeholder-text{color:var(--shadow)}
#assets-folder-fieldset{position:relative}
#assets-folder-actions{display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem}
#assets-folder-actions p{font-size:1.1rem;margin:0}
#mg-view-all-local-assets-btn{position:absolute;top:-14px;right:12px;width:auto;padding:2px 8px;font-size:16px;margin:0}
body[data-theme-name="classic light"] .mg-btn.active{color:var(--bg)}

#project-library-popup{width:90%;max-width:800px;height:80vh;padding:0;display:flex;flex-direction:column}
#project-library-popup .titlebar{flex-shrink:0}
#project-library-popup .overlay-close-btn{margin-left:auto}
#mg-asset-picker-wrapper .overlay-close-btn{position:absolute;top:10px;right:12px}
#project-library-grids-container{flex-grow:1;overflow-y:auto}
.project-library-grid { padding: 1rem; display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 1rem; align-content: flex-start; height: 100%; box-sizing: border-box; }
.project-library-grid h5{grid-column:1/-1;text-align:left;font-size:1.25rem;margin:.5rem 0 0;border-bottom:2px solid var(--mid);padding-bottom:4px}
.library-grid-item{width:100%;aspect-ratio:1/1;border:2px solid var(--ink);background:color-mix(in srgb,var(--light) 90%,var(--ink) 10%);position:relative;box-shadow:3px 3px 0 var(--ink);transition:transform .15s ease-out,box-shadow .15s ease-out;border-radius:3px}
.library-grid-item .delete-btn,.library-grid-item .favorite-btn{position:absolute;top:-8px;background:var(--danger-color);color:var(--light);border:2px solid var(--ink);width:24px;height:24px;font-size:16px;cursor:pointer;display:flex;align-items:center;justify-content:center;line-height:1;z-index:2;opacity:0;transition:all .15s ease-out;border-radius:2px;font-family:monospace}
.library-grid-item .delete-btn{right:-8px}
.library-grid-item .favorite-btn{left:-8px;background:var(--mid);color:var(--ink);box-shadow:1px 1px 0 var(--ink)}
.library-grid-item .delete-btn:hover,.library-grid-item .favorite-btn:hover{transform:translateY(-1px);box-shadow:2px 2px 0 var(--ink)}
.library-grid-item .delete-btn:active,.library-grid-item .favorite-btn:active{transform:scale(.95) translateY(1px);box-shadow:none}
.library-grid-item .favorite-btn.is-favorite{background-color:var(--action-color);transform:translateY(1px);box-shadow:none}
.library-grid-item .favorite-btn::before{font-family:"Font Awesome 6 Free";font-weight:400;content:"\f005";transition:font-weight .2s,color .2s}
.library-grid-item .favorite-btn.is-favorite::before{color:var(--light)}
.library-grid-item .favorite-btn:hover::before,.library-grid-item .favorite-btn.is-favorite::before{font-weight:900}
.library-grid-item:hover .delete-btn,.library-grid-item:hover .favorite-btn{opacity:1}
.library-grid-item>div{cursor:pointer;width:100%;height:100%}
.library-grid-item:hover{transform:translate(-2px,-2px) scale(1.03);box-shadow:5px 5px 0 var(--ink);border-color:var(--action-color)}
.library-grid-item img,.library-grid-item video{width:100%;height:100%;object-fit:cover;pointer-events:none}
.overlay-close-btn{width:16px;height:16px;background:var(--danger-color);border:2px solid var(--ink);color:var(--ink);font-family:'VT323',monospace;font-size:14px;line-height:1;display:flex;align-items:center;justify-content:center;padding:0;cursor:pointer;z-index:10;transition:filter .2s}
.overlay-close-btn:hover{filter:brightness(1.2)}
.layer-thumb{position:relative}
/* --- Add this code inside your <style> tag --- */

/* 1. Set up the button container for wrapping and increased spacing */
.action-buttons {
    flex-wrap: wrap;
    gap: 0.75rem; /* Increased gap for more vertical spacing */
}

/* 2. IMPORTANT: Reset margins on ALL buttons in this section for consistency */
fieldset .mg-btn {
    margin: 0;
}

/* 3. Make "Start Live Session" full-width and appear first */
#mg-start-session-btn {
    order: 1;
    width: 100%;
}

/* 4. Make "Save Project" appear second and grow to fill half the space */
#mg-save-project-btn {
    order: 2;
    flex-grow: 1;  /* This tells the button to grow */
    flex-basis: 0; /* This ensures it grows from an even starting point */
}

/* 5. Make "Clear Canvas" appear third and fill the other half */
#mg-clear-canvas-btn {
    order: 3;
    flex-grow: 1;
    flex-basis: 0;
}

/* 6. Ensure the standalone "Download Image" button is also full-width */
#mg-download-image-btn {
    width: 100%;
}
/* --- Add this code inside your <style> tag --- */

/* Fix for dark theme readability on the share link popup */
#share-link-input {
    color: var(--ink);
}
.optimization-badge{position:absolute;bottom:2px;right:2px;width:14px;height:14px;background-color:var(--success-color);color:var(--light);border-radius:50%;font-size:10px;font-weight:700;display:flex;align-items:center;justify-content:center;line-height:1;border:1px solid var(--ink);box-shadow:1px 1px 0 var(--shadow);z-index:2}
.optimization-badge.pending{background-color:var(--mid);animation:pulse 1.5s infinite}
@keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.1)}100%{transform:scale(1)}}
#mg-asset-picker-wrapper.window{background:rgba(var(--light-rgb),.85);-webkit-backdrop-filter:blur(8px);backdrop-filter:blur(8px);border:2px solid var(--ink);box-shadow:4px 4px 0 var(--ink);padding:2rem;max-width:450px;width:90vw;text-align:center;color:var(--ink);height:auto;max-height:90vh}
body[data-theme-is-dark=true] #mg-asset-picker-wrapper,body[data-theme-is-dark=true] #mg-asset-picker-wrapper .overlay-close-btn{color:var(--ink)}
#mg-asset-picker-wrapper h4{font-size:1.8rem;font-weight:400;margin:0 0 .5rem}
#mg-asset-picker-wrapper>p{font-size:1rem;margin:0 0 1.5rem}
#mg-asset-drop-zone{border:4px dashed var(--mid);border-radius:10px;padding:2rem;color:var(--mid);cursor:pointer;transition:all .2s ease-in-out;display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;aspect-ratio:1/1}
#mg-asset-drop-zone h3{font-size:1.5rem;margin:0 0 .5rem;pointer-events:none}
#mg-asset-drop-zone p{font-size:1rem;margin:0;pointer-events:none}
#mg-asset-drop-zone.drag-over,#mg-asset-drop-zone:hover{border-color:var(--ink);color:var(--ink);background-color:rgba(var(--action-color-rgb),.1);border-style:solid}
#add-new-text-layer-btn { width: 44px !important; height: 44px; flex-shrink: 0; font-size: 2rem; line-height: 1; padding: 0; background: color-mix(in srgb, var(--light) 90%, var(--ink) 10%); border: 2px solid var(--ink); color: var(--mid); box-shadow: 2px 2px 0 var(--shadow); border-radius: 3px; transition: transform .15s ease-out, box-shadow .15s ease-out; }
#add-new-text-layer-btn:hover { transform: translate(1px, 1px); box-shadow: 1px 1px 0 var(--shadow); }
#add-new-text-layer-btn:active { transform: translate(2px, 2px); box-shadow: none; }
.empty-library-placeholder { display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; padding: 2rem; min-height: 300px; color: var(--mid); height: 100%; box-sizing: border-box; }
.empty-library-placeholder i { font-size: 3.5rem; margin-bottom: 1.5rem; opacity: 0.7; }
.empty-library-placeholder h3 { font-size: 1.5rem; color: var(--ink); margin: 0 0 0.5rem 0; }
.empty-library-placeholder p { font-size: 1.1rem; max-width: 350px; line-height: 1.4; margin: 0; }

/* Style for the button in its "loading" state */
.mg-btn.is-loading {
    cursor: wait;
    opacity: 0.8;
}

.mg-btn.is-loading::after {
    content: '.';
    display: inline-block;
    width: 3ch; /* Make space for up to three dots */
    text-align: left;
    animation: ellipsis 1.4s infinite;
}
</style>
</head>
<body>
<script>const themes={'classic light':{name:'classic light',isDark:!1,colors:['#f2efe8','#2b2b2b','#d98c5f'],css:{'--bg':'#f2efe8','--ink':'#2b2b2b','--mid':'#c2c2c2','--light':'#faf9f5','--shadow':'#7a7a7a','--action-color':'#2b2b2b','--danger-color':'#cc4444','--success-color':'#55cc55'}},dark:{name:'dark',isDark:!0,colors:['#1a1d2d','#e0e5f0','#e8a85a'],css:{'--bg':'#1a1d2d','--ink':'#e0e5f0','--mid':'#3d4a6e','--light':'#252a40','--shadow':'#0d0f16','--action-color':'#e0e5f0','--danger-color':'#a83e3e','--success-color':'#4a9d4a'}},'イーピーイッピ':{name:'イーピーイッピ',isDark:!0,colors:['#5c3d46','#dcd0c0','#a26769'],css:{'--bg':'#2a1d21','--ink':'#dcd0c0','--mid':'#5c3d46','--light':'#402d32','--shadow':'#1a1114','--action-color':'#a26769','--danger-color':'#a26769','--success-color':'#69a267'}},zarah:{name:'zarah',isDark:!1,colors:['#7b9c98','#eaf1f3','#5c3d46'],css:{'--bg':'#7b9c98','--ink':'#eaf1f3','--mid':'#5c3d46','--light':'#6c8985','--shadow':'#3c2a30','--action-color':'#eaf1f3'}},lavender:{name:'lavender',isDark:!1,colors:['#b3b3d9','#282846','#656599'],css:{'--bg':'#b3b3d9','--ink':'#282846','--mid':'#656599','--light':'#c4c4e2','--shadow':'#47476b','--action-color':'#8c58a6'}},café:{name:'café',isDark:!1,colors:['#ceb18d','#4e43f','#d4d2d1'],css:{'--bg':'#ceb18d','--ink':'#4e433f','--mid':'#d4d2d1','--light':'#f7f2ea','--shadow':'#8a7a6a','--action-color':'#8a6ea2'}},mizu:{name:'mizu',isDark:!1,colors:['#b8dceb','#091f2c','#89a5bb'],css:{'--bg':'#b8dceb','--ink':'#091f2c','--mid':'#89a5bb','--light':'#cfe5ee','--shadow':'#627382','--action-color':'#005a8e'}},'キティ':{name:'キティ',isDark:!1,colors:['#fdf6e3','#657b83','#93a1a1'],css:{'--bg':'#fdf6e3','--ink':'#657b83','--mid':'#93a1a1','--light':'#eee8d5','--shadow':'#586e75','--action-color':'#268bd2'}},aura:{name:'aura',isDark:!0,colors:['#29423D','#EAE8E1','#C9A59C'],css:{'--bg':'#1A2A27','--ink':'#EAE8E1','--mid':'#3E5D56','--light':'#29423D','--shadow':'#111C19','--action-color':'#C9A59C','--danger-color':'#b05454','--success-color':'#5a9e7a'}},'Pastel Dreams':{name:'Pastel Dreams',isDark:!1,colors:['#CDB4DB','#3D314A','#FFAFCC'],css:{'--bg':'#FFC8DD','--ink':'#3D314A','--mid':'#CDB4DB','--light':'#FFF0F5','--shadow':'#B596B1','--action-color':'#A2D2FF','--danger-color':'#FFB3C1','--success-color':'#BDE0FE'}},'Midnight':{name:'Midnight',isDark:!0,colors:['#161618','#b0b0b0','#a8a5ff'],css:{'--bg':'#161618','--ink':'#b0b0b0','--mid':'#000000','--light':'#212121','--shadow':'#0a0a0a','--action-color':'#a8a5ff','--danger-color':'#b74545','--success-color':'#054e3c'}}};</script>



</body>
</html><div class=window>
    <div id=loading-overlay><h1>Initializing Image-Maker-Studio.exe</h1></div>
    <div class=titlebar>
        <span>Image-Maker-Studio.exe</span>
      <div class=titlebar-controls>
    <button id=toggle-view-btn title="Toggle Canvas View (Z)">⬚</button>
    <button id=visuals-btn>Edit Visuals</button>
    <button id=text-btn>Text</button> 
    <button id=erase-tool-btn>Erase</button>
    <button id=ai-tools-btn>BG Remover.exe</button>
    <button id=shortcuts-btn>Shortcuts</button>
    <div class=controls-fake>
        <div class=btn-square></div>
        <div class=btn-square></div>
    </div>
            <div id=shortcuts-dropdown>
                <h5>Keyboard Shortcuts</h5>
                <ul><li><span>Undo Last Action</span><kbd>Cmd/Ctrl + Z</kbd></li><li><span>Redo Last Action</span><kbd>Cmd/Ctrl + Y</kbd></li><li><span>Toggle Canvas View</span><kbd>Z</kbd></li><li><span>Enlarge Asset</span><kbd>D</kbd></li><li><span>Shrink Asset</span><kbd>F</kbd></li><li><span>Flip Asset Horizontally</span><kbd>S</kbd></li><li><span>Move Layer Forward</span><kbd>Q</kbd></li><li><span>Move Layer Backward</span><kbd>W</kbd></li><li><span>Delete Asset</span><kbd>Delete</kbd></li><li><span>Save Project</span><kbd>Cmd/Ctrl + S</kbd></li></ul>
            </div>
        </div>
    </div>
    <main id=studio-container>
        <div id=controls-panel>
            <!-- Panel 1: Default View -->
            <div id="default-panel" class="control-panel active">
                <fieldset id="assets-folder-fieldset">
                    <legend>Project Library</legend>
                    <button id="mg-view-all-local-assets-btn" class="mg-btn" title="Open the Project Library to see all saved projects, assets, & backgrounds">Open Library</button>
                    <div id="assets-folder-actions">
                        <p>Your recent assets</p>
                    </div>
                    <div id="mg-local-asset-palette"></div>
                    <p style="font-size:1.1rem;margin-top:.6rem;margin-bottom:.5rem">Your recent backgrounds</p>
                    <div id="mg-local-background-palette"></div>
                </fieldset>
                <fieldset id="layers-fieldset">
                    <legend>Layers</legend>
                    <p id="layer-instructions" class="placeholder-text">Add a background to begin.</p>
                    <div id="mg-asset-palette"></div>
                </fieldset>
                <fieldset>
                    <legend>Project Actions</legend>
                    <div class="action-buttons" style="margin-bottom:.5rem;display:flex;gap:.5rem">
                        <button class="mg-btn" id="mg-save-project-btn" title="Save project to the Project Library (Ctrl+S)" disabled>Save Project</button>
                        <button class="mg-btn" id="mg-start-session-btn" title="Start a live collaboration session">Start Live Session</button>
                        <button class="mg-btn" id="mg-clear-canvas-btn" title="Start over with a blank canvas" disabled>Clear Canvas</button>
                    </div>
                    <button class="mg-btn generate" id="mg-download-image-btn" title="Download the final image as a PNG file" disabled>Download Image</button>
                </fieldset>
            </div>
            <!-- Panel 2: Visuals Editor -->
            <div id="visuals-panel" class="control-panel">
                <div class="panel-header"><button class="back-button" data-target="default-panel">←</button><h5>Visuals Editor</h5></div>
                <div id=visuals-tabs class=eraser-mode-selector style=margin-bottom:.8rem><button id=visuals-tab-asset class=visuals-main-tab-btn type=button>Asset</button><button id=visuals-tab-background class="visuals-main-tab-btn active" type=button>Background</button></div>
                <div id=asset-tab-panel class=hidden><div id=asset-visuals-controls class=disabled><h6>Filters</h6><div class=slider-container><label for=asset-opacity>Opacity</label><input type=range id=asset-opacity min=0 max=1 step=.01 value=1></div><div class=slider-container><label for=asset-brightness>Brightness</label><input type=range id=asset-brightness min=0 max=2 step=.01 value=1></div><div class=slider-container><label for=asset-saturation>Saturation</label><input type=range id=asset-saturation min=0 max=2 step=.01 value=1></div><h6>Drop Shadow</h6><div class=effects-checkbox style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem"><div><input type=checkbox id=shadow-enable><label for=shadow-enable>Enable</label></div><input type=color id=shadow-color value=#000000 style="width:100px;height:25px;border:1px solid var(--ink);padding:0"></div><div id=shadow-controls class="effects-controls disabled"><div class=slider-container><label for=shadow-blur>Blur</label><input type=range id=shadow-blur min=0 max=50 value=10></div><div class=slider-container><label for=shadow-offset-x>Offset X</label><input type=range id=shadow-offset-x min=-50 max=50 value=10></div><div class=slider-container><label for=shadow-offset-y>Offset Y</label><input type=range id=shadow-offset-y min=-50 max=50 value=10></div></div><h6>Edge</h6><div class=effects-checkbox style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem"><div><input type=checkbox id=asset-edge-enable><label for=asset-edge-enable>Enable</label></div><input type=color id=asset-edge-color value=#FFFFFF style="width:100px;height:25px;border:1px solid var(--ink);padding:0"></div><div id=asset-edge-controls class="effects-controls disabled"><div class=slider-container><label for=asset-edge-width>Width</label><input type=range id=asset-edge-width min=0 max=20 value=4></div></div></div></div>
                <div id=background-tab-panel><div id=background-visuals-controls><h6>Background Filters</h6><div class=slider-container><label for=bg-brightness>Brightness</label><input type=range id=bg-brightness min=0 max=2 step=.01 value=1></div><div class=slider-container><label for=bg-saturation>Saturation</label><input type=range id=bg-saturation min=0 max=2 step=.01 value=1></div></div></div>
            </div>
            <!-- Panel 3: Eraser Tool -->
            <div id="eraser-panel" class="control-panel">
                <div class="panel-header"><button class="back-button" data-target="default-panel">←</button><h5>Eraser Tool</h5></div>
                <div class=eraser-mode-selector><button class=mg-btn id=erase-btn>Erase</button><button class=mg-btn id=unerase-btn>Unerase</button></div><div id=eraser-controls-wrapper class=disabled><div class=slider-container><label for=eraser-size>Size</label><input type=range id=eraser-size min=5 max=250 value=128></div><div class=slider-container><label for=eraser-strength>Strength</label><input type=range id=eraser-strength min=0 max=1 step=.01 value=1></div></div>
            </div>
            <!-- Panel 4: AI Tools -->
            <div id="ai-tools-panel" class="control-panel">
                <div class="panel-header"><button class="back-button" data-target="default-panel">←</button><h5>BG Remover.exe</h5></div>
                <!-- Content from addBgUI() will be added here by JS -->
            </div>
            <!-- Panel 5: Text Editor -->
            <div id="text-panel" class="control-panel">
                <div class="panel-header"><button class="back-button" data-target="default-panel">←</button><h5>Text Editor</h5></div>
                <div id=text-layer-manager><div id=text-layer-palette></div><button id=add-new-text-layer-btn class="palette-slot empty" title="Add new text layer">+</button></div><div id=text-visuals-controls class=disabled><div class=slider-container><label for=text-content>Text Content</label><textarea id=text-content rows=3 style="width:100%;font-family:inherit;font-size:1rem;padding:4px;border:1px solid var(--ink);background:var(--bg);line-height:1.1">New Text</textarea></div>
                <div class=slider-container><label>Font</label><div id=custom-font-select><div id=font-select-trigger tabindex=0><span>VT323</span> <i class="fas fa-chevron-down"></i></div><div id=font-select-dropdown class=hidden><ul id=font-select-list></ul></div></div>
                <button id="open-font-preview-btn" class="mg-btn" style="width: 100%; margin: 0.5rem 0 0 0; padding: 4px 8px; font-size: 1rem;">Visual Font Selector</button>
                </div>
                <div class=slider-container><label for=text-size>Size</label><input type=range id=text-size min=20 max=800 step=1 value=410></div><div class=compact-color-row><div class=slider-container><label for=text-color>Color</label><input type=color id=text-color value=#FFFFFF></div><div class=slider-container><label for=text-edge-color>Edge Color</label><input type=color id=text-edge-color value=#000000></div></div><div class=slider-container><label for=text-edge-width>Edge Density</label><input type=range id=text-edge-width min=0 max=20 step=.1 value=0></div><h6>Drop Shadow</h6><div class=effects-checkbox style="display:flex;justify-content:space-between;align-items:center"><div><input type=checkbox id=text-shadow-enable><label for=text-shadow-enable>Enable</label></div><div class=slider-container style="margin-bottom:0;width:60%"><label for=text-shadow-color style=margin-top:0>Color</label><input type=color id=text-shadow-color value=#000000 style="width:100%;border:none;padding:0"></div></div><div id=text-shadow-controls class="effects-controls disabled"><div class=slider-container><label for=text-shadow-blur>Blur</label><input type=range id=text-shadow-blur min=0 max=50 value=10></div><div class=slider-container><label for=text-shadow-offset-x>Offset X</label><input type=range id=text-shadow-offset-x min=-50 max=50 value=10></div><div class=slider-container><label for=text-shadow-offset-y>Offset Y</label><input type=range id=text-shadow-offset-y min=-50 max=50 value=10></div></div><div id=text-zorder-controls style="display:flex;gap:.5rem;align-items:center;margin-top:.5rem"><button id=text-move-back class=mg-btn type=button style="width:auto;padding:2px 8px">Move back</button><button id=text-move-forward class=mg-btn type=button style="width:auto;padding:2px 8px">Move forward</button></div>
                </div>
            </div>
        </div>
        <div id=canvas-panel>
            <canvas id=mg-movie-canvas></canvas>
            <canvas id=mg-controls-overlay-canvas></canvas>
            <canvas id=mg-pasteboard-overlay-canvas></canvas>
            <div id=canvas-placeholder><img src="welcome.png" alt="Click or drag and drop to start creating"><h3>Click, Paste, or Drag & Drop File</h3><p>to add a background image & begin creating</p></div>
        </div>
    </main>
    <footer><div class=footer-links><a href=#><i class="fas fa-envelope"></i>feedback</a><a href=#><i class="fab fa-twitter"></i>updates</a><a href=#><i class="fas fa-file-alt"></i>license</a><a href=#><i class="fas fa-shield-alt"></i>report</a><a href=#><i class="fas fa-lock"></i>privacy</a></div><div class=footer-right><a href=# id=theme-select-link><i class="fas fa-palette"></i><span id=current-theme-name></span></a><a href=# id=version-link><i class="fas fa-code-branch"></i>v4.18.1</a></div></footer>
    <input type=file id=initial-background-input accept=image/* style=display:none>
</div>
<div id=mg-asset-library-overlay class=mg-overlay-base><div id=mg-asset-picker-wrapper class=window><button id=mg-asset-library-close class=overlay-close-btn>X</button><h4>Add a New Layer</h4><p>Add your own image to the current scene.</p><div id=mg-asset-drop-zone><h3>Click, Paste, or Drag & Drop File</h3><p>Supported formats: PNG, JPG, JPEG</p></div><div id=mg-asset-picker-actions><input type=file id=mg-asset-picker-file accept="image/png, image/jpeg" style=display:none></div></div></div>
<div id=project-library-popup-overlay class=mg-overlay-base><div id=project-library-popup class=window><div class=titlebar><span>Project Library</span><button id=project-library-popup-close class=overlay-close-btn>X</button></div><div class=library-tabs style="padding:.5rem 1rem;display:flex;gap:.5rem;border-bottom:2px solid var(--ink)"><button id=library-tab-projects class=visuals-main-tab-btn>Projects</button><button id=library-tab-assets class="visuals-main-tab-btn active">Assets</button><button id=library-tab-backgrounds class=visuals-main-tab-btn>Backgrounds</button><button id=library-tab-favorites class=visuals-main-tab-btn>Favorites</button></div><div id=project-library-grids-container style="flex-grow:1;overflow-y:auto"><div id=project-library-grid-projects class="project-library-grid hidden"></div><div id=project-library-grid-assets class=project-library-grid></div><div id=project-library-grid-backgrounds class="project-library-grid hidden"></div><div id=project-library-grid-favorites class="project-library-grid hidden"></div></div></div></div>
<div id=mg-confirmation-overlay class=mg-overlay-base><div id=mg-confirmation-dialog class=window><p id=mg-confirmation-text>Are you sure?</p><div class=action-buttons><button id="mg-confirm-yes-btn" class="mg-btn active" type=button>Yes</button><button id="mg-confirm-no-btn" class=mg-btn type=button>No</button></div></div></div>
<div id=mg-asset-action-overlay class=mg-overlay-base style="display:none"><div id=mg-asset-action-dialog class=window><p>How would you like to use this asset?</p><div class=action-buttons><button id=mg-asset-action-background-btn class=mg-btn>Set as Background</button><button id=mg-asset-action-layer-btn class=mg-btn>Add as Layer</button></div></div></div>
<div id=version-popup-overlay style="display:none"><div id=version-popup-content><span id=close-popup>X</span><h4>v4.18.1</h4><h6>12 Sep 2025</h6><p>A performance and user experience patch focused on improving initial load times and refining UI elements based on user feedback.</p><h5>Features</h5><ul><li><strong>performance:</strong> Implemented "critical CSS" to ensure the loading screen appears almost instantly. Non-essential styles are now loaded asynchronously.</li><li><strong>performance:</strong> Decorative fonts are now loaded on-demand when the user opens the Text Editor for the first time, saving multiple network requests on initial load.</li></ul><h5>Improvements</h5><ul><li><strong>performance:</strong> Removed the background removal tool to significantly reduce the initial JavaScript bundle size.</li><li><strong>performance:</strong> Replaced the welcome video with a static, compressed PNG to speed up the placeholder view.</li><li><strong>ux:</strong> The border style selector popup is now a perfectly sized, non-scrollable grid with centered previews and improved spacing.</li><li><strong>ux:</strong> Previews in the border style selector now use the theme's main ink color (e.g., black) instead of green for better visual consistency.</li><li><strong>ui:</strong> Added small 'x' markers to the corners of the "Classic Barb" border preview to better reflect its on-canvas appearance.</li></ul><h5>Fixes</h5><ul><li><strong>style:</strong> Corrected the "Classic Wiggle" rotator handle on the canvas, which was incorrectly showing a black fill; it now correctly shows only the green stroke.</li></ul><hr style=margin:2rem 0><h4>v4.18.0</h4><h6>11 Sep 2025</h6><p>A major update focused on UI/UX enhancements and bug fixes, particularly for the editing tools.</p><h5>Features</h5><ul><li><strong>ui:</strong> re-architected the 'Edit Visuals' dropdown into a tabbed interface ("Asset" and "Background") to improve organization and ensure it fits on smaller screens</li><li><strong>eraser:</strong> added a floating side HUD that appears when the eraser tool is active, providing quick access to primary controls without reopening the main dropdown</li><li><strong>ux:</strong> implemented a smooth "scrubbing" effect for sliders, which fades out non-essential UI elements during adjustment for better focus</li></ul><h5>Improvements</h5><ul><li><strong>style:</strong> reduced border and box-shadow thickness sitewide for a lighter, more refined aesthetic</li><li><strong>eraser:</strong> redesigned the side HUD with clear "Erase" and "Unerase" buttons that dynamically match the application's selected theme</li><li><strong>eraser:</strong> added a "Strength" slider to the side HUD for quick access to both primary brush settings</li><li><strong>eraser:</strong> refined the activation flow to keep the main dropdown open for initial adjustments; the side HUD now appears only after the user moves to the canvas</li><li><strong>ui:</strong> added smooth fade-in and fade-out transitions to the eraser's side HUD and magnifying zoom window for a more polished feel</li><li><strong>ux:</strong> the "Asset" tab in the Visuals Editor is now always clickable and provides a helpful toast message if no asset is currently selected</li><li><strong>ux:</strong> improved instructional text for the eraser, changing "Armed" to "Activated" and clarifying how to deactivate the tool</li><li><strong>text:</strong> renamed "Stroke Width" to "Density" in the Text Editor</li><li><strong>performance:</strong> capped the eraser's undo history to a maximum of 10 steps per layer to prevent excessive memory usage</li></ul><h5>Fixes</h5><ul><li><strong>download:</strong> implemented a missing `toast` function that was causing a critical error and preventing the "Download Image" button from working</li><li><strong>eraser:</strong> the floating side HUD no longer incorrectly disappears when a user interacts with its sliders</li><li><strong>eraser:</strong> the Size and Strength sliders are now perfectly synced in real-time between the main dropdown and the side HUD</li><li><strong>eraser:</strong> the side HUD now correctly disappears the moment an erase action begins (mouse-down) and reappears immediately upon release (mouse-up)</li><li><strong>ui:</strong> disabled the "scrubbing" fade-out effect for all "Strength" sliders, as hiding the UI was not necessary for that specific adjustment</li></ul></div></div>
<div id=theme-popup-overlay style="display:none"><div id=theme-popup-content><ul id=theme-list></ul></div></div>
<div id="save-changes-overlay" class="mg-overlay-base">
    <div id="save-changes-dialog" class="window" style="padding:1.5rem;text-align:center;width:90%;max-width:450px;height:auto">
        <p id="save-changes-text" style="font-size:1.2rem;margin:0 0 1.5rem">
            You have unsaved changes. Do you want to save your current work before loading a new project?
        </p>
        <div class="action-buttons" style="display:flex;justify-content:center;gap:.5rem">
            <button id="confirm-save-continue-btn" class="mg-btn success" type="button">Save & Continue</button>
            <button id="confirm-discard-continue-btn" class="mg-btn" type="button">Discard & Continue</button>
            <button id="confirm-cancel-load-btn" class="mg-btn" type="button" style="background:var(--mid)">Cancel</button>
        </div>
    </div>
</div>
<!-- New Font Preview Modal -->
<div id="font-preview-overlay" class="mg-overlay-base">
    <div id="font-preview-dialog" class="window" style="padding: 0; width: 90%; max-width: 1000px; height: 85vh; display: flex; flex-direction: column;">
        <div class="titlebar">
            <span>Visual Font Selector</span>
            <button id="font-preview-close-btn" class="overlay-close-btn">X</button>
        </div>
        <div id="font-preview-grid" style="flex-grow: 1; overflow-y: auto; padding: 1.5rem;">
            <!-- Font previews will be dynamically inserted here -->
        </div>
    </div>
</div>

<!-- *** CORRECTED PLACEMENT FOR SHARE MODAL *** -->
<div id="share-session-overlay" class="mg-overlay-base">
    <div id="share-session-dialog" class="window" style="padding:1.5rem;text-align:center;width:90%;max-width:550px;height:auto">
        <button id="share-session-close-btn" class="overlay-close-btn" style="position:absolute;top:10px;right:12px">X</button>
        <h4 style="font-size:1.8rem;margin:0 0 .5rem">Live Session Started</h4>
        <p style="font-size:1.1rem;margin:0 0 1.5rem">
            Share this private link with others to collaborate in real-time. The session is end-to-end encrypted.
        </p>
        <div style="display:flex; gap: 0.5rem;">
            <input type="text" id="share-link-input" readonly style="width:100%;font-family:monospace;font-size:0.9rem;padding:8px;border:1px solid var(--ink);background:var(--bg);">
            <button id="copy-share-link-btn" class="mg-btn" style="width:auto;margin:0;white-space:nowrap;">Copy Link</button>
        </div>
    </div>
</div>

<div id=mg-toast></div>

<script>
    ! function() {
        try {
            const e = localStorage.getItem('selectedTheme') || 'Midnight',
                t = themes[e];
            if (t) {
                const o = document.createElement('style'),
                    s = Object.entries(t.css).map(([e, t]) => `${e}: ${t};`).join('');
                o.textContent = `:root { ${s} }`, document.head.appendChild(o), document.body.dataset.themeName = e
            }
        } catch (e) {
            console.warn("Theme pre-loader failed. Storage might be inaccessible in this environment (e.g., private browsing).", e)
        }
    }();
</script>
<script>
    const ImageMakerStudio = {
       config: {
            secondaryFontsLoaded: false,
            loadedFonts: new Set(['VT323']),
            themes: {},
            PASTEBOARD_MARGIN: 1500,
            FADE_IN_DURATION: 300,
            HISTORY_LIMIT: 15,
            DEBOUNCE_DELAY: 500,
            availableFonts: [
                { name: 'VT323', value: "'VT323', monospace" }, { name: 'Yomogi', value: "'Yomogi', cursive" },
                { name: 'Young Serif', value: "'Young Serif', serif" }, { name: 'Special Elite', value: "'Special Elite', cursive" },
                { name: 'Rubik Mono One', value: "'Rubik Mono One', sans-serif" }, { name: 'Rubik Beastly', value: "'Rubik Beastly', cursive" },
                { name: 'Press Start 2P', value: "'Press Start 2P', cursive", style: "font-size: 0.6rem;" }, { name: 'Patua One', value: "'Patua One', cursive" },
                { name: 'Nosifer', value: "'Nosifer', cursive" }, { name: 'Monoton', value: "'Monoton', cursive" },
                { name: 'Modak', value: "'Modak', cursive" }, { name: 'Metal Mania', value: "'Metal Mania', cursive" },
                { name: 'Major Mono Display', value: "'Major Mono Display', monospace", style: "font-size: 0.8rem;" }, { name: 'Luckiest Guy', value: "'Luckiest Guy', cursive" },
                { name: 'Londrina Outline', value: "'Londrina Outline', cursive" }, { name: 'Joti One', value: "'Joti One', cursive" },
                { name: 'Gorditas', value: "'Gorditas', cursive" }, { name: 'Graduate', value: "'Graduate', cursive" },
                { name: 'Gloria Hallelujah', value: "'Gloria Hallelujah', cursive" }, { name: 'Frijole', value: "'Frijole', cursive" },
                { name: 'Erica One', value: "'Erica One', cursive" }, { name: 'Eater', value: "'Eater', cursive" },
                { name: 'Dokdo', value: "'Dokdo', cursive" }, { name: 'Cute Font', value: "'Cute Font', cursive" },
                { name: 'Creepster', value: "'Creepster', cursive" }, { name: 'Codystar', value: "'Codystar', cursive" },
                { name: 'Barrio', value: "'Barrio', cursive" }, { name: 'Bahiana', value: "'Bahiana', cursive" },
                { name: 'Astloch', value: "'Astloch', cursive" }, { name: 'Are You Serious', value: "'Are You Serious', cursive" }
            ],
            fontValueToNameMap: new Map(),
             BG_MODELS: { fast: 'model.onnx' },//for local testing
             //  BG_MODELS: { fast: 'https://huggingface.co/briaai/RMBG-1.4/resolve/main/onnx/model.onnx' for github
        },
        
        state: {
            addAssetMode: 'layer',
            originalTheme: 'classic light',
            themeChosen: false,
            canvasState: { currentProjectId: null, backgroundElement: null, backgroundType: 'none', backgroundHash: null, bgBrightness: 1, bgSaturation: 1, layers: [], dominantColor: null },
            assetCache: {},
            activeLayerId: null,
            movieInteraction: { active: false, didDrag: false },
            animationFrameId: null,
            isAnimatingRender: false,
            masterWidth: 0,
            masterHeight: 0,
            isCanvasViewZoomedOut: false,
            eraserMode: 'none',
            isEraserArmed: false,
            eraseBrushPos: { x: 0, y: 0 },
            originalFontOnHover: null,
            toastTimeout: null,
            toastAnimationInterval: null,
            confirmCallback: null,
            lastEraseCanvasPoint: null,
            bgSessionCache: new Map(),
            history: [],
            historyIndex: -1,
            converterWorker: null,
            pendingProjectId: null,
            lastSavedStateHash: null,
            onnxLoaded: false,
        },

        dom: {},

reducer(state, action) {
            // This is a "pure" function. It only calculates the next state.
            switch (action.type) {
                case 'LAYER_PROPERTY_CHANGED': { const { layerId, property, value } = action.payload; return { ...state, canvasState: { ...state.canvasState, layers: state.canvasState.layers.map(l => l.id !== layerId ? l : { ...l, [property]: value }) } }; }
                case 'LAYER_SHADOW_CHANGED': { const { layerId, property, value } = action.payload; return { ...state, canvasState: { ...state.canvasState, layers: state.canvasState.layers.map(l => l.id !== layerId ? l : { ...l, shadow: { ...l.shadow, [property]: value } }) } }; }
                case 'LAYER_BORDER_CHANGED': { const { layerId, property, value } = action.payload; return { ...state, canvasState: { ...state.canvasState, layers: state.canvasState.layers.map(l => l.id !== layerId ? l : { ...l, border: { ...l.border, [property]: value } }) } }; }
                case 'BACKGROUND_FILTER_CHANGED': { const { property, value } = action.payload; return { ...state, canvasState: { ...state.canvasState, [property]: value } }; }
                case 'BACKGROUND_CHANGED': { const { backgroundHash } = action.payload; return { ...state, canvasState: { ...state.canvasState, backgroundHash, bgBrightness: 1, bgSaturation: 1 } }; }
                case 'LAYER_ADDED': { const { newLayer } = action.payload; return { ...state, activeLayerId: newLayer.id, canvasState: { ...state.canvasState, layers: [newLayer, ...state.canvasState.layers] } }; }
                case 'LAYER_DELETED': { const { layerId } = action.payload; return { ...state, activeLayerId: state.activeLayerId === layerId ? null : state.activeLayerId, canvasState: { ...state.canvasState, layers: state.canvasState.layers.filter(l => l.id !== layerId) } }; }
                case 'LAYER_REORDERED': { const { layerId, delta } = action.payload; const newLayers = [...state.canvasState.layers]; const i = newLayers.findIndex(l => l.id === layerId); if (i === -1) return state; const j = i + delta; if (j < 0 || j >= newLayers.length) return state; const [item] = newLayers.splice(i, 1); newLayers.splice(j, 0, item); return { ...state, canvasState: { ...state.canvasState, layers: newLayers } }; }
                case 'LAYER_TRANSFORMED': { const { layerId, x, y, size, fontSize, rot } = action.payload; return { ...state, canvasState: { ...state.canvasState, layers: state.canvasState.layers.map(layer => { if (layer.id !== layerId) return layer; const newLayer = { ...layer, x, y }; if (size !== undefined && layer.type === 'image') newLayer.size = size; if (fontSize !== undefined && layer.type === 'text') newLayer.fontSize = fontSize; if (rot !== undefined) newLayer.rot = rot; return newLayer; }) } }; }
                
                // --- NEW CASE ADDED HERE ---
                case 'LAYER_REFIT_AND_TRANSFORM': {
                    const { layerId, transform } = action.payload;
                    return {
                        ...state,
                        canvasState: {
                            ...state.canvasState,
                            layers: state.canvasState.layers.map(l => {
                                if (l.id !== layerId) return l;

                                // Return a completely new layer object with all the updated properties
                                return {
                                    ...l,
                                    x: transform.x,
                                    y: transform.y,
                                    size: transform.size,
                                    propX: transform.propX,
                                    propY: transform.propY,
                                    propSize: transform.propSize,
                                    proxyCanvas: transform.proxyCanvas,
                                    proxyCtx: transform.proxyCtx,
                                    contentFrame: transform.contentFrame,
                                    // Increment version to ensure thumbnails and other caches update
                                    contentVersion: (l.contentVersion || 0) + 1,
                                };
                            })
                        }
                    };
                }

                case 'LAYER_OPTIMIZATION_COMPLETE': {
                    const { layerId, newAsset, newSrc, newProxyCanvas, newProxyCtx, newContentFrame, wasOptimized } = action.payload;
                    return {
                        ...state,
                        canvasState: {
                            ...state.canvasState,
                            layers: state.canvasState.layers.map(l => {
                                if (l.id !== layerId) return l;
                                
                                // Revoke the old blob URL to prevent memory leaks if it exists
                                if (l.originalTempSrc) { URL.revokeObjectURL(l.originalTempSrc); }

                                return {
                                    ...l,
                                    asset: newAsset,
                                    src: newSrc,
                                    originalTempSrc: null,
                                    proxyCanvas: newProxyCanvas,
                                    proxyCtx: newProxyCtx,
                                    contentFrame: newContentFrame,
                                    isOptimized: wasOptimized
                                };
                            })
                        }
                    };
                }

                default: return state;
            }
        },
        dispatch(action, isRemote = false) {
            if (!isRemote && this.collaborationManager.socket) {
                this.collaborationManager.broadcastAction(action);
            }
            const oldState = this.state;
            const newState = this.reducer(this.state, action);
            this.state = newState;
            if (isRemote) {
                if (newState.canvasState.backgroundHash !== oldState.canvasState.backgroundHash) {
                    this.loadAndSetBackgroundFromHash(newState.canvasState.backgroundHash);
                }
                if (action.type === 'LAYER_PROPERTY_CHANGED' && action.payload.property === 'font') {
                    const fontName = this.config.fontValueToNameMap.get(action.payload.value);
                    if (fontName) { this.loadSpecificFonts([fontName]); }
                }
            }
            this.renderLayerPalette();
            this.renderTextLayerPalette();
            if (!this.state.movieInteraction.active) {
                this.drawFrame();
            }
        },
        // =====================================================================

        async loadAndInitializeLayer(layerId) {
            const layer = this.state.canvasState.layers.find(l => l.id === layerId);
            if (!layer || layer.asset) return; // Already loaded

            try {
                const assetRecords = await this.idbFindByHash(layer.originalHash);
                if (assetRecords.length === 0) throw new Error("Asset not found for layer.");

                const img = new Image();
                img.src = URL.createObjectURL(assetRecords[0].full);
                await img.decode();
                
                // Now we update the layer in the state with the real image and proxy canvas
                // This is a direct mutation, but it's okay here because it's a "post-processing" step.
                layer.asset = img;
                const proxyCanvas = document.createElement('canvas');
                // ... (code to create the proxy canvas from the image) ...
                layer.proxyCanvas = proxyCanvas;

                this.renderLayerPalette();
                this.triggerAnimatedRender();
                this.saveState();
            } catch (error) {
                console.error("Failed to initialize layer:", error);
                // Optionally remove the broken layer from the state
            }
        },

       panelManager: {
            app: null,
            activePanel: 'default-panel',
            panels: {},
            buttonMap: {},
            
            // ADD THIS FUNCTION BACK
            init(app) {
                this.app = app;
                this.panels = {
                    'default-panel': document.getElementById('default-panel'),
                    'visuals-panel': document.getElementById('visuals-panel'),
                    'text-panel': document.getElementById('text-panel'),
                    'eraser-panel': document.getElementById('eraser-panel'),
                    'ai-tools-panel': document.getElementById('ai-tools-panel'),
                };
                this.buttonMap = {
                    'visuals-panel': this.app.dom.visualsBtn,
                    'text-panel': this.app.dom.textBtn,
                    'eraser-panel': this.app.dom.eraseToolBtn,
                    'ai-tools-panel': this.app.dom.aiToolsBtn,
                };
            },

            show(panelId) {
                if (this.activePanel === panelId) return;
                Object.values(this.buttonMap).forEach(btn => btn.classList.remove('btn-active'));
                if (this.buttonMap[panelId]) {
                    this.buttonMap[panelId].classList.add('btn-active');
                }
                if (this.activePanel === 'eraser-panel' && panelId !== 'eraser-panel') {
                    this.app.deactivateEraser();
                }
                const currentPanel = this.panels[this.activePanel];
                if (currentPanel) {
                    currentPanel.classList.remove('active');
                }
                const nextPanel = this.panels[panelId];
                if (nextPanel) {
                    setTimeout(() => nextPanel.classList.add('active'), 10);
                    this.activePanel = panelId;
                }
            }
        },
  collaborationManager: {
    app: null,
    socket: null,
    roomId: null,
    encryptionKey: null,

    init(app) { this.app = app; },

    // --- UTILITY FUNCTIONS (UNCHANGED) ---
    _arrayBufferToBase64(buffer) { let b = ''; const B = new Uint8Array(buffer); for (let i = 0; i < B.byteLength; i++) { b += String.fromCharCode(B[i]); } return window.btoa(b); },
    _base64ToArrayBuffer(base64) { const s = window.atob(base64); const l = s.length; const b = new Uint8Array(l); for (let i = 0; i < l; i++) { b[i] = s.charCodeAt(i); } return b.buffer; },
    async _encrypt(data) { const iv = window.crypto.getRandomValues(new Uint8Array(12)); const encoded = new TextEncoder().encode(JSON.stringify(data)); const enc = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv }, this.encryptionKey, encoded); return `${this._arrayBufferToBase64(iv)}.${this._arrayBufferToBase64(enc)}`; },
    async _decrypt(encryptedString) { try { const [iv64, d64] = encryptedString.split('.'); if (!iv64 || !d64) throw new Error("Invalid format."); const iv = this._base64ToArrayBuffer(iv64); const d = this._base64ToArrayBuffer(d64); const dec = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv }, this.encryptionKey, d); return JSON.parse(new TextDecoder().decode(dec)); } catch (e) { console.error("Decryption failed:", e); return null; } },
    async generateEncryptionKey() { const k = await window.crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]); this.encryptionKey = k; return this._arrayBufferToBase64(await window.crypto.subtle.exportKey("raw", k)); },

    // --- PRIMARY SESSION LOGIC (COMPLETELY REVISED) ---
   async startSession() {
            if (this.socket) {
                console.warn("A session is already active.");
                return;
            }

            console.log("Attempting to start a new live session...");
            const startTime = Date.now();
            const startBtn = this.app.dom.startSessionBtn;
            const originalBtnText = startBtn.textContent;

            // 1. Set the UI to its "loading" state immediately.
            startBtn.textContent = 'Starting';
            startBtn.classList.add('is-loading');
            startBtn.disabled = true;
            this.app.showLoadingScreen('Establishing Encrypted E2E Connection');

            // This function will reset the UI, ensuring the button is never left in a broken state.
            const resetUI = (errorMessage) => {
                this.app.hideLoadingScreen();
                if (errorMessage) {
                    this.app.toast(errorMessage, 5000);
                }
                startBtn.textContent = originalBtnText;
                startBtn.classList.remove('is-loading');
                startBtn.disabled = false;
                this.socket = null; // Ensure socket state is cleared.
            };

            try {
                const keyString = await this.generateEncryptionKey();

                // 2. Create a promise that attempts to connect to the WebSocket server.
                const connectionPromise = new Promise((resolve, reject) => {
                    // --- THIS IS THE CORRECTED LINE ---
                    const ws = new WebSocket('wss://vella-interjectural-defiantly.ngrok-free.dev');
                    
                    // Set a timeout. If we don't connect within 8 seconds, fail.
                    const connectionTimeout = setTimeout(() => {
                        ws.close(); // This triggers the 'onclose' event, which calls reject.
                        reject(new Error('Connection timed out.'));
                    }, 8000);

                    ws.onopen = () => {
                        console.log("WebSocket connection opened, requesting room...");
                        ws.send(JSON.stringify({ type: 'create_room' }));
                    };
                    
                    ws.onmessage = (event) => {
                        const message = JSON.parse(event.data);
                        if (message.type === 'room_created') {
                            console.log("Room successfully created on server:", message.roomId);
                            clearTimeout(connectionTimeout); // We connected, so cancel the timeout.
                            resolve({ roomId: message.roomId, keyString, ws }); // Success!
                        }
                    };

                    // Handle failures
                    ws.onerror = (event) => {
                        clearTimeout(connectionTimeout);
                        console.error("WebSocket error event:", event);
                        reject(new Error('Connection failed. Is the server running?'));
                    };
                    ws.onclose = () => {
                        clearTimeout(connectionTimeout);
                        console.log("WebSocket connection closed.");
                        // Only reject if we haven't already resolved.
                        if (!this.roomId) {
                           reject(new Error('Connection was closed before setup completed.'));
                        }
                    };
                });

                // 3. Wait for the connection to succeed.
                const sessionData = await connectionPromise;

                // --- SUCCESS PATH ---
                console.log("Connection promise resolved successfully.");
                
                // 4. Ensure the loading screen has been visible for at least 2.5 seconds.
                const elapsedTime = Date.now() - startTime;
                const remainingTime = 3500 - elapsedTime;
                if (remainingTime > 0) {
                    await new Promise(resolve => setTimeout(resolve, remainingTime));
                }

                // 5. Finalize the successful connection state.
                this.socket = sessionData.ws;
                this.roomId = sessionData.roomId;
                
                // Re-assign event handlers for the long-lived session
                this.socket.onmessage = (event) => this.handleServerMessage(event);
                this.socket.onclose = () => {
                    this.app.toast("Live session disconnected.", 3000);
                    resetUI(null); // Reset UI without an error message.
                };

                this.app.hideLoadingScreen();
                startBtn.textContent = 'Session Active';
                startBtn.classList.remove('is-loading');
                
                // Show the share link modal after a brief delay for a smooth transition.
                setTimeout(() => this.showShareLinkModal(this.roomId, sessionData.keyString), 250);

            } catch (error) {
                // --- FAILURE PATH ---
                console.error("Failed to establish session:", error.message);
                
                // 6. Ensure the loading screen has been visible for 2.5 seconds before showing the error.
                const elapsedTime = Date.now() - startTime;
                const remainingTime = 3500 - elapsedTime;
                if (remainingTime > 0) {
                    await new Promise(resolve => setTimeout(resolve, remainingTime));
                }
                
                // 7. Reset the UI and show the error message.
                resetUI(error.message);
            }
        },

    async joinSession(roomId, keyString) {
        if (this.socket) { return; }
        try {
            const keyData = this._base64ToArrayBuffer(keyString);
            this.encryptionKey = await window.crypto.subtle.importKey("raw", keyData, { name: "AES-GCM" }, true, ["encrypt", "decrypt"]);
            this.roomId = roomId;
            this.socket = new WebSocket('wss://vella-interjectural-defiantly.ngrok-free.dev');
            this.socket.onopen = () => { this.socket.send(JSON.stringify({ type: 'join', roomId: this.roomId })); };
            this.socket.onmessage = (event) => this.handleServerMessage(event);
            this.socket.onerror = (error) => { console.error("WebSocket Error:", error); this.socket = null; };
            this.socket.onclose = () => { this.socket = null; this.roomId = null; this.encryptionKey = null; };
        } catch (e) { console.error("Failed to join session:", e); window.location.hash = ''; }
    },

    async handleServerMessage(event) {
        let message;
        try { message = JSON.parse(event.data); } catch (e) {
            const decryptedAction = await this._decrypt(event.data);
            if (decryptedAction) {
                if (decryptedAction.type === 'LAYER_ADDED' && decryptedAction.payload.newLayer.type === 'image' && decryptedAction.payload.newLayer.assetDataUrl) {
                    const blob = this.app.dataURLtoBlob(decryptedAction.payload.newLayer.assetDataUrl);
                    await this.app.saveAssetToLibrary({blob, mime: blob.type, hash: decryptedAction.payload.newLayer.originalHash, kind: 'asset'});
                    const hydratedLayer = await this.app.createLayerFromSrc(URL.createObjectURL(blob), decryptedAction.payload.newLayer);
                    this.app.dispatch({ type: 'LAYER_ADDED', payload: { newLayer: hydratedLayer } }, true);
                } else {
                    this.app.dispatch(decryptedAction, true);
                }
            }
            return;
        }
        switch (message.type) {
            case 'new_user_joined': this.app.toast("A new user joined.", 1500); const s = await this.app.getSavableState(true); const e = await this._encrypt(s); this.socket.send(JSON.stringify({ type: 'sync_data', roomId: this.roomId, payload: e })); break;
            case 'sync_data': this.app.toast("Receiving current state...", null); const d = await this._decrypt(message.payload); if (d) { await this.app.restoreProjectState(d); this.app.toast("✅ Session Synced!", 2000); } break;
        }
    },

    checkForSessionInUrl() { const h = window.location.hash; if (h.startsWith('#room=')) { const [r, k] = h.substring(6).split(','); if (r && k) { setTimeout(() => this.joinSession(r, k), 100); } } },

    showShareLinkModal(r, k) { const u = `${window.location.href.split('#')[0]}#room=${r},${k}`; this.app.dom.shareLinkInput.value = u; this.app.dom.shareSessionOverlay.classList.add('visible'); },
    
    hideShareLinkModal() { this.app.dom.shareSessionOverlay.classList.remove('visible'); },

    async broadcastAction(action) {
        if (!this.socket || this.socket.readyState !== WebSocket.OPEN) return;
        if (action.type === 'LAYER_ADDED' && action.payload.newLayer.type === 'image' && action.payload.newLayer.originalHash) {
            const assetRecords = await this.app.idbFindByHash(action.payload.newLayer.originalHash);
            if (assetRecords.length > 0) {
                action.payload.newLayer.assetDataUrl = await this.app.toDataURL(assetRecords[0].full);
            }
        }
        const e = await this._encrypt(action);
        this.socket.send(JSON.stringify({ type: 'message', roomId: this.roomId, payload: e }));
    }
},
        // ====================================================================


        throttle(func, delay) {
            let inProgress = false;
            return (...args) => {
                if (inProgress) {
                    return;
                }
                inProgress = true;
                // Use setTimeout to wait for the delay period to end
                setTimeout(() => {
                    func(...args); // Call the function once the delay is over
                    inProgress = false;
                }, delay);
            };
        },
        
        loadOnnxRuntime() {
            return new Promise((resolve, reject) => {
                if (window.ort) { resolve(); return; }
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/ort.min.js';
                script.onload = resolve;
                script.onerror = reject;
                document.body.appendChild(script);
            });
        },
        
        getDominantColor(element) {
            const tempCanvas = document.createElement('canvas');
            const ctx = tempCanvas.getContext('2d', { willReadFrequently: true });
            tempCanvas.width = 1; tempCanvas.height = 1;
            ctx.drawImage(element, 0, 0, 1, 1);
            const data = ctx.getImageData(0, 0, 1, 1).data;
            return `${data[0]}, ${data[1]}, ${data[2]}`;
        },

        async loadAndSetBackgroundFromHash(hash) {
            if (!hash) {
                this.clearCanvas(); // If the hash is null, clear the canvas.
                return;
            }
            try {
                const bgAssets = await this.idbFindByHash(hash);
                if (!bgAssets || bgAssets.length === 0) {
                    // This can happen if the asset hasn't synced yet, we can add a retry later if needed.
                    throw new Error(`Background asset with hash ${hash} not found in library.`);
                }
                const img = new Image();
                img.src = URL.createObjectURL(bgAssets[0].full);
                img.onload = () => {
                    // We call setBackground directly, but mark it as 'isRestoring'
                    // to prevent it from creating a new history state.
                    this.setBackground(img, hash, true);
                };
                img.onerror = () => { throw new Error("Failed to load background image from blob."); };
            } catch (error) {
                console.error("Failed to load background from hash:", error);
                this.toast("Error: Could not sync background.", 4000);
            }
        },
        
        updateSliderFill(slider) {
            if(!slider) return;
            const percentage = ((slider.value - slider.min) / (slider.max - slider.min)) * 100;
            const bg = `linear-gradient(to right, var(--action-color) ${percentage}%, var(--mid) ${percentage}%)`;
            slider.style.background = bg;
        },
        
        updateCanvasPanelBackground() {
            if (this.state.isCanvasViewZoomedOut) {
                this.dom.canvasPanel.style.backgroundColor = '';
                this.dom.canvasPanel.style.backdropFilter = '';
                this.dom.canvasPanel.style.webkitBackdropFilter = '';
                return;
            }
            if (this.state.canvasState.dominantColor) {
                this.dom.canvasPanel.style.backgroundColor = `rgba(${this.state.canvasState.dominantColor}, 0.4)`;
                this.dom.canvasPanel.style.backdropFilter = 'blur(15px)';
                this.dom.canvasPanel.style.webkitBackdropFilter = 'blur(15px)';
            } else {
                this.dom.canvasPanel.style.backgroundColor = 'var(--mid)';
                this.dom.canvasPanel.style.backdropFilter = 'none';
                this.dom.canvasPanel.style.webkitBackdropFilter = 'none';
            }
        },

        loadSpecificFonts(fontNames) {
            if (!Array.isArray(fontNames) || fontNames.length === 0) return Promise.resolve();
            const fontsToLoad = fontNames.filter(f => !this.config.loadedFonts.has(f));
            if (fontsToLoad.length === 0) return Promise.resolve();
            const batchSize = 10;
            const promises = [];
            for (let i = 0; i < fontsToLoad.length; i += batchSize) {
                const batch = fontsToLoad.slice(i, i + batchSize);
                const baseUrl = 'https://fonts.googleapis.com/css2?';
                const familyParams = batch.map(font => `family=${font.replace(/ /g, '+')}`).join('&');
                const url = `${baseUrl}${familyParams}&display=swap`;
                const promise = new Promise((resolve, reject) => {
                    const link = document.createElement('link');
                    link.href = url;
                    link.rel = 'stylesheet';
                    link.onload = () => { batch.forEach(f => this.config.loadedFonts.add(f)); resolve(); };
                    link.onerror = () => { console.error('Failed to load a batch of fonts:', batch); reject(new Error(`Could not load font batch: ${batch.join(', ')}`)); };
                    document.head.appendChild(link);
                });
                promises.push(promise);
            }
            return Promise.all(promises);
        },

        loadSecondaryFonts() {
            if (this.config.secondaryFontsLoaded) return Promise.resolve();
            const allFontNames = this.config.availableFonts.map(f => f.name);
            return this.loadSpecificFonts(allFontNames).then(() => { this.config.secondaryFontsLoaded = true; });
        },

        injectNonCriticalStyles() {
            const nonCriticalCSS = `
            textarea#text-content, #font-select-trigger span {color:var(--ink)}
            .titlebar button { transform:translateY(-1px); }
            .titlebar button:hover{transform:translateY(-2px);filter:brightness(1.1)}
            .titlebar button:active{transform:translateY(0);border-color:var(--ink) var(--mid) var(--mid) var(--ink)}
'#controls-panel fieldset{background:var(--light);border:1px solid var(--ink);padding:.8rem;margin:0;text-align:left;transition:background-color .3s,border-color .3s,color .3s,opacity .15s;border-radius:3px}'            #controls-panel legend{font-size:1.2rem;font-weight:400;padding:0 .5rem;margin-left:.5rem;background:var(--light)}
            .placeholder-text{color:var(--mid);font-size:1.1rem;text-align:center;padding:1rem;width:100%}
            body[data-theme-is-dark=true] #layer-instructions{color:var(--ink)}
            #mg-asset-palette,#mg-local-asset-palette,#mg-local-background-palette{display:flex;gap:.5rem;flex-wrap:wrap;min-height:70px;align-content:flex-start}
.palette-overlay-btn{position:absolute;bottom:-6px;right:-6px;width:24px;height:24px;font-size:1.8rem;line-height:1;display:flex;align-items:center;justify-content:center;background:var(--light);border:2px solid var(--ink);color:var(--ink);box-shadow:2px 2px 0 var(--shadow);border-radius:3px;z-index:5;cursor:pointer;transition:all .2s ease-out}.palette-overlay-btn:hover{transform:translate(-1px,-1px) scale(1.1);box-shadow:3px 3px 0 var(--shadow);background:var(--action-color);color:var(--light)}            .palette-slot,.layer-thumb{width:60px;height:60px;border:1px solid var(--ink);background:color-mix(in srgb, var(--light) 90%, var(--ink) 10%);cursor:pointer;position:relative;border-radius:3px;box-shadow:3px 3px 0 var(--ink);transform:translate(0,0);transition:transform .15s ease-out,box-shadow .15s ease-out}
            .palette-slot.empty{display:flex;align-items:center;justify-content:center;font-size:3rem;line-height:1;color:var(--mid)}
            .layer-thumb:hover,.palette-slot.empty:hover{transform:translate(-2px,-2px);box-shadow:5px 5px 0 var(--ink)}
            .layer-thumb.active{transform:translate(1px,1px);box-shadow:none;border:2px solid var(--action-color)}
            .layer-thumb{cursor:grab}
            .layer-thumb img, .layer-thumb canvas{width:100%;height:100%;object-fit:cover;pointer-events:none}
            .layer-controls{position:absolute;top:-5px;right:-5px;display:flex;gap:2px}
            .layer-btn{background-color:var(--danger-color);border:1px solid var(--ink);color:#fff;font-size:.8rem;font-weight:700;line-height:1;padding:1px 4px;cursor:pointer;width:18px;height:18px;text-align:center}
            #mg-movie-canvas,#mg-controls-overlay-canvas,#mg-pasteboard-overlay-canvas{position:absolute}
            #mg-controls-overlay-canvas,#mg-pasteboard-overlay-canvas{pointer-events:none}
            #mg-movie-canvas{pointer-events:auto}
            #mg-toast{visibility:hidden;position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:var(--light);border:1px solid var(--ink);padding:.5rem 1rem;color:var(--ink);font-size:1rem;z-index:2000;box-shadow:2px 2px 0 var(--shadow)}
            #canvas-placeholder{position:absolute;width:calc(100% - 20px);height:calc(100% - 20px);border:2px dashed var(--mid);border-radius:10px;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;cursor:pointer;color:var(--mid);transition:all .2s;padding:2rem;overflow:hidden;position:relative}
            #canvas-placeholder h3,#canvas-placeholder p{position:relative;z-index:2}
            #canvas-placeholder img{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;z-index:1;opacity:.6}
            #canvas-placeholder h3{font-size:2.2rem;margin:0 0 .5rem}
            #canvas-placeholder p{font-size:1.3rem}
            #canvas-placeholder:hover,#canvas-panel.drag-over #canvas-placeholder{border-color:var(--ink);color:var(--ink);background-color:rgba(255,255,255,.5)}
            #canvas-panel.drag-over{background-color:var(--shadow)}
            #layer-instructions{padding:0 0 .5rem 0;margin:0;font-size:1.1rem}
            #mg-confirmation-overlay,#mg-asset-action-overlay{z-index:5000}
            #mg-confirmation-dialog,#mg-asset-action-dialog{padding:1.5rem;text-align:center;width:90%;max-width:400px;height:auto}
            #mg-confirmation-dialog p,#mg-asset-action-dialog p{font-size:1.2rem;margin:0 0 1.5rem}
            #mg-confirmation-dialog .action-buttons,#mg-asset-action-dialog .action-buttons{display:flex;justify-content:center;gap:.5rem}
            #text-content,#text-font{transition:background-color .3s,border-color .3s,color .3s}
            #text-layer-manager{display:flex;gap:.5rem;align-items:center;padding-bottom:.5rem;margin-bottom:.5rem;border-bottom:1px solid var(--mid)}
            #text-layer-palette{display:flex;gap:.5rem;flex-wrap:wrap;flex-grow:1;min-height:44px}
            #add-new-text-layer-btn{width:40px;height:40px;flex-shrink:0;font-size:2rem;line-height:1;padding:0}
            .text-thumb{width:60px;height:40px;display:flex;align-items:center;justify-content:center;overflow:hidden;background-color:var(--ink);color:var(--light);font-size:.8rem;padding:2px;text-align:center}
            .text-thumb span{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;pointer-events:none}
            .palette-slot.empty:disabled{opacity:.4;cursor:default;pointer-events:none;background-color:var(--light)}
            .palette-slot.empty:disabled:hover{background-color:var(--light);color:var(--mid)}
            #shortcuts-btn:disabled,#visuals-btn:disabled,#text-btn:disabled,#erase-tool-btn:disabled,#ai-tools-btn:disabled{opacity:.5;pointer-events:none;cursor:default}
            .layer-thumb.dragging{opacity:.4;transform:rotate(-3deg) scale(1.05);box-shadow:0 8px 20px rgba(0,0,0,.3);cursor:grabbing}
            .layer-thumb.drag-over{border:3px dashed var(--action-color);transform:scale(1.02);background-color:rgba(var(--action-color-rgb),.1)}
            #mg-pasteboard-overlay-canvas{position:absolute;pointer-events:none;display:none}
            #canvas-panel.is-zoomed-out{background-color:var(--shadow)}
            #mg-movie-canvas,#mg-controls-overlay-canvas,#mg-pasteboard-overlay-canvas{transition:transform .3s ease-in-out,box-shadow .3s ease-in-out}
            #canvas-panel.is-zoomed-out #mg-movie-canvas,#canvas-panel.is-zoomed-out #mg-controls-overlay-canvas,#canvas-panel.is-zoomed-out #mg-pasteboard-overlay-canvas{transform:scale(.8);box-shadow:0 0 15px rgba(0,0,0,.5)}
            #canvas-panel.is-zoomed-out #mg-controls-overlay-canvas{display:none}
            #canvas-panel.is-zoomed-out #mg-pasteboard-overlay-canvas{display:block}
            #toggle-view-btn:disabled,#toggle-view-btn:disabled:hover{opacity:.5;pointer-events:none;cursor:default}
            .effects-checkbox{display:flex;align-items:center;margin-top:.5rem}
            .effects-checkbox input{margin-right:.5rem}
            .effects-controls{padding-left:1.5rem;border-left:1px solid var(--mid);margin-left:.5rem}
            .effects-controls.disabled{opacity:.5;pointer-events:none}
            #erase-tool-btn.active{background-color:var(--action-color);color:var(--light)}
            #mg-movie-canvas.erase-cursor{cursor:none}
            .eraser-mode-selector{display:flex;gap:.5rem;margin-bottom:.5rem}
            .eraser-mode-selector .mg-btn{width:50%;margin:0;padding:4px 8px;font-size:16px}
            .eraser-mode-selector .mg-btn:active,.eraser-mode-selector .mg-btn.active{background-color:var(--action-color);color:var(--light);transform:none;box-shadow:inset 1px 1px 0 rgba(0,0,0,.2)}
            #theme-popup-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);display:none;justify-content:center;align-items:center;z-index:7000}
            #theme-popup-content{background:var(--bg);border:1px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);padding:1rem;width:90%;max-width:400px;max-height:80vh;display:flex;flex-direction:column;transition:background-color .3s}
            #theme-list{list-style:none;margin:0;padding:0;overflow-y:auto}
            #theme-list li{padding:.75rem 1rem;cursor:pointer;display:flex;justify-content:space-between;align-items:center;transition:background-color .2s;border-radius:4px}
            #theme-list li.active{background-color:var(--action-color);color:var(--light)}
            body[data-theme-is-dark=true] #theme-list li.active{color:var(--bg)}
            #theme-list li.active span{flex-grow:1}
            #theme-list li.active::before{content:'✓';margin-right:.5rem}
            #theme-list li:not(.active):hover{background-color:var(--mid)}
            .theme-colors{display:flex;gap:.5rem}
            .theme-color-dot{width:16px;height:16px;border-radius:50%;border:1px solid var(--ink)}
            #version-popup-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.7);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);display:none;justify-content:center;align-items:center;z-index:6000}
            #version-popup-content{background-color:var(--bg);padding:2rem;border:1px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);width:80%;height:80%;max-width:800px;position:relative;color:var(--ink);overflow-y:auto}
            #version-popup-content h4{font-size:2rem;margin-bottom:.5rem}
            #version-popup-content h6{font-size:1rem;margin-top:0;opacity:.7;margin-bottom:1.5rem}
            #version-popup-content h5{font-size:1.5rem;margin-top:1.5rem;border-bottom:1px solid var(--mid);padding-bottom:.25rem}
            #version-popup-content ul{list-style:none;padding-left:0}
            #version-popup-content li{margin-bottom:.75rem;line-height:1.4}
            #close-popup{position:absolute;top:1rem;right:1.5rem;font-size:2rem;color:var(--ink);cursor:pointer;font-family:'VT323',monospace;line-height:1;transition:opacity .2s}
            #close-popup:hover{opacity:.6}
            #custom-font-select{position:relative}
            #font-select-trigger{background:var(--bg);border:1px solid var(--ink);padding:4px 8px;font-size:1rem;cursor:pointer;display:flex;justify-content:space-between;align-items:center;transition:background-color .3s,border-color .3s}
            #font-select-trigger:focus,#custom-font-select.open #font-select-trigger{border-color:var(--action-color)}
            #font-select-trigger span{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
            #font-select-trigger i{transition:transform .2s ease-in-out;font-size:.8em}
            #custom-font-select.open #font-select-trigger i{transform:rotate(180deg)}
            #font-select-dropdown{position:absolute;top:calc(100% + 2px);left:0;right:0;background:var(--light);border:1px solid var(--ink);z-index:101;max-height:250px;overflow-y:auto;box-shadow:2px 2px 0 var(--shadow)}
            #font-select-list{list-style:none;margin:0;padding:0}
            #font-select-list li{padding:6px 10px;cursor:pointer;transition:background-color .2s;white-space:nowrap;font-size:.9rem}
            #font-select-list li:hover,#font-select-list li.hover-preview{background-color:var(--mid)}
            #font-select-list li.selected{background-color:var(--action-color);color:var(--light)}
            body[data-theme-is-dark=true] #font-select-list li.selected{color:var(--bg)}`;
            const style = document.createElement('style');
            style.textContent = nonCriticalCSS;
            document.head.appendChild(style);
        },

        applyTheme(themeName, isPreview = false) {
            const theme = themes[themeName];
            if (!theme) return;
            const root = document.documentElement;
            if (isPreview) { root.style.transition = 'none'; }
            for (const [key, value] of Object.entries(theme.css)) {
                root.style.setProperty(key, value);
                if (key === '--light') root.style.setProperty('--light-rgb', this.hexToRgb(value));
                if (key === '--bg') root.style.setProperty('--bg-rgb', this.hexToRgb(value));
                if (key === '--action-color') root.style.setProperty('--action-color-rgb', this.hexToRgb(value));
            }
            document.body.dataset.themeIsDark = theme.isDark;
            document.body.dataset.themeName = themeName;
            if (isPreview) { void root.offsetWidth; root.style.transition = ''; }
        },

        async createOptimizedBlob(blob, maxDimension = 2048, quality = 0.9) {
            try {
                const bmp = await createImageBitmap(blob);
                const { width, height } = bmp;
                if (Math.max(width, height) <= maxDimension && blob.type === 'image/webp') {
                    return blob; // It's already good enough
                }
                const scale = Math.min(maxDimension / width, maxDimension / height, 1);
                const newWidth = Math.round(width * scale);
                const newHeight = Math.round(height * scale);
                const c = new OffscreenCanvas(newWidth, newHeight);
                c.getContext('2d').drawImage(bmp, 0, 0, newWidth, newHeight);
                return await c.convertToBlob({ type: 'image/webp', quality });
            } catch (e) {
                console.error("Could not optimize image, returning original blob.", e);
                return blob; // Fallback
            }
        },

        dataURLtoBlob(dataurl) {
            const arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1];
            const bstr = atob(arr[1]);
            let n = bstr.length;
            const u8arr = new Uint8Array(n);
            while(n--){ u8arr[n] = bstr.charCodeAt(n); }
            return new Blob([u8arr], {type:mime});
        },

        hexToRgb(hex) {
            let r=0,g=0,b=0;
            if(hex.length==4){r=parseInt(hex[1]+hex[1],16);g=parseInt(hex[2]+hex[2],16);b=parseInt(hex[3]+hex[3],16)}
            else if(hex.length==7){r=parseInt(hex[1]+hex[2],16);g=parseInt(hex[3]+hex[4],16);b=parseInt(hex[5]+hex[6],16)}
            return `${r},${g},${b}`;
        },

        saveAndApplyTheme(themeName) {
            this.state.themeChosen = true;
            this.applyTheme(themeName);
            try {
                localStorage.setItem('selectedTheme', themeName);
            } catch (e) {
                console.error("Could not save theme. Storage may be disabled or full.", e);
                this.toast("Could not save theme preference.", 3000);
            }
            this.state.originalTheme = themeName;
            this.dom.currentThemeNameSpan.textContent = themeName;
            const currentActive = this.dom.themeList.querySelector('.active');
            if (currentActive) currentActive.classList.remove('active');
            const newActive = this.dom.themeList.querySelector(`[data-theme-name="${themeName}"]`);
            if (newActive) newActive.classList.add('active');
            this.dom.themePopupOverlay.style.display = 'none';
        },

        populateThemeList() {
            this.dom.themeList.innerHTML = '';
            const currentTheme = localStorage.getItem('selectedTheme') || 'classic light';
            for (const themeName in themes) {
                const theme = themes[themeName];
                const li = document.createElement('li');
                li.dataset.themeName = themeName;
                if(themeName === currentTheme) li.classList.add('active');
                let content = `<span>${theme.name}</span>`;
                let colorDots = '<div class="theme-colors">';
                theme.colors.forEach(color => { colorDots += `<div class="theme-color-dot" style="background-color: ${color};"></div>`; });
                colorDots += '</div>';
                li.innerHTML = content + colorDots;
                li.addEventListener('click', () => this.saveAndApplyTheme(themeName));
                li.addEventListener('mouseenter', () => this.applyTheme(themeName, true));
                this.dom.themeList.appendChild(li);
            }
        },
        
        showLoadingScreen(message = 'Loading...') {
            this.dom.loadingMessage.textContent = message;
            this.dom.loadingOverlay.style.display = 'flex';
            void this.dom.loadingOverlay.offsetWidth; 
            this.dom.loadingOverlay.style.opacity = '1';
        },

        hideLoadingScreen() {
            this.dom.loadingOverlay.style.opacity = '0';
            setTimeout(() => {
                this.dom.loadingOverlay.style.display = 'none';
            }, 500);
        },

        toast(message, duration = 3000) {
            if (!this.dom.toastEl) return;
            clearTimeout(this.state.toastTimeout);
            clearInterval(this.state.toastAnimationInterval);
            this.dom.toastEl.textContent = message;
            this.dom.toastEl.style.visibility = 'visible';
            if (duration !== null) {
                this.state.toastTimeout = setTimeout(() => {
                    this.dom.toastEl.style.visibility = 'hidden';
                    clearInterval(this.state.toastAnimationInterval);
                }, duration);
            }
        },

        hideToast() {
            if (!this.dom.toastEl) return;
            clearTimeout(this.state.toastTimeout);
            clearInterval(this.state.toastAnimationInterval);
            this.dom.toastEl.style.visibility = 'hidden';
        },

        async sha256Hex(blob) {
            const buf = await blob.arrayBuffer();
            const digest = await crypto.subtle.digest('SHA-256', buf);
            const bytes = new Uint8Array(digest);
            return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
        },

        idbOpen(dbName = 'ims-db') {
            return new Promise((resolve, reject) => {
                if (!window.indexedDB) {
                    console.error("IndexedDB is not supported by this browser.");
                    this.toast("Project Library is not available.", 4000);
                    return reject(new Error("IndexedDB not supported."));
                }
                const req = indexedDB.open(dbName, 6);
                req.onupgradeneeded = (e) => {
                    const db = req.result;
                    if (!db.objectStoreNames.contains('assets')) {
                        const assetsStore = db.createObjectStore('assets', { keyPath: 'id', autoIncrement: true });
                        assetsStore.createIndex('createdAt', 'createdAt');
                        assetsStore.createIndex('hash', 'hash', { unique: false });
                        assetsStore.createIndex('kind', 'kind', { unique: false });
                    }
                    if (!db.objectStoreNames.contains('projects')) {
                        const projectsStore = db.createObjectStore('projects', { keyPath: 'id', autoIncrement: true });
                        projectsStore.createIndex('createdAt', 'createdAt');
                    }
                    if (e.oldVersion < 5) {
                        const assetsStore = req.transaction.objectStore('assets');
                        if (!assetsStore.indexNames.contains('isFavorite')) {
                            assetsStore.createIndex('isFavorite', 'isFavorite');
                        }
                    }
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => {
                    console.error("IndexedDB error:", req.error);
                    this.toast("Could not access Project Library.", 4000);
                    reject(req.error);
                };
            });
        },

        generateCanvasStateHash() {
            if (!this.state.canvasState.backgroundElement && this.state.canvasState.layers.length === 0) {
                return 'empty';
            }
            const serializableState = {
                bgBrightness: this.state.canvasState.bgBrightness,
                bgSaturation: this.state.canvasState.bgSaturation,
                backgroundHash: this.state.canvasState.backgroundHash,
                layers: this.state.canvasState.layers.map(layer => {
                    const { asset, proxyCanvas, proxyCtx, createdAt, ...leanLayer } = layer;
                    return leanLayer;
                })
            };
            return JSON.stringify(serializableState);
        },
        isCanvasDirty() {
            const currentHash = this.generateCanvasStateHash();
            return currentHash !== this.state.lastSavedStateHash;
        },

        async _actuallyLoadProject(projectId) {
            this.showLoadingScreen('Loading Project');
            const minDisplayTime = new Promise(resolve => setTimeout(resolve, 1200));
            const loadingPromise = (async () => {
                const projectRecord = await this.idbGet(projectId, 'projects');
                if (!projectRecord) throw new Error("Project not found.");
                projectRecord.projectState.currentProjectId = projectId;
                await this.restoreProjectState(projectRecord.projectState);
            })();
            try {
                await Promise.all([minDisplayTime, loadingPromise]);
                this.dom.projectLibraryPopupOverlay.classList.remove('visible');
                this.toast("Project loaded.", 2000);
            } catch (e) {
                console.error("Failed to load project from library:", e);
                this.toast(`Error: Could not load project. ${e.message}`, 4000);
            } finally {
                this.hideLoadingScreen();
                this.state.lastSavedStateHash = this.generateCanvasStateHash();
            }
        },

        async idbGet(id, storeName) {
            try {
                const db = await this.idbOpen();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(storeName, 'readonly');
                    const req = tx.objectStore(storeName).get(id);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            } catch (error) {
                console.error(`Failed to get record '${id}' from '${storeName}'.`, error);
                return Promise.reject(error);
            }
        },

        async idbPut(record, storeName) {
            try {
                const db = await this.idbOpen();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(storeName, 'readwrite');
                    const store = tx.objectStore(storeName);
                    const isUpdate = record.id != null;
                    const req = isUpdate ? store.put(record) : store.add(record);
                    req.onsuccess = () => { if (!isUpdate) { record.id = req.result; } };
                    tx.oncomplete = () => resolve(record);
                    tx.onerror = () => reject(tx.error);
                });
            } catch (error) {
                console.error(`Failed to put record into '${storeName}'.`, error);
                this.toast("Error: Could not save data.", 4000);
                return Promise.reject(error);
            }
        },

        async idbGetAll(storeName) {
            try {
                const db = await this.idbOpen();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(storeName, 'readonly');
                    const req = tx.objectStore(storeName).getAll();
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            } catch (error) {
                console.error(`Failed to get all records from '${storeName}'.`, error);
                return Promise.reject(error);
            }
        },

        async idbDelete(id, storeName) {
            try {
                const db = await this.idbOpen();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(storeName, 'readwrite');
                    tx.objectStore(storeName).delete(id);
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            } catch (error) {
                console.error(`Failed to delete record '${id}' from '${storeName}'.`, error);
                this.toast("Error: Could not delete data.", 4000);
                return Promise.reject(error);
            }
        },
        
        async idbFindByHash(hash) {
            try {
                const db = await this.idbOpen();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction('assets', 'readonly');
                    const os = tx.objectStore('assets');
                    const idx = os.index('hash');
                    const req = idx.getAll(hash);
                    req.onsuccess = () => resolve(req.result || []);
                    req.onerror = () => reject(req.error);
                });
            } catch (error) {
                console.error(`Failed to find record by hash from 'assets'.`, error);
                return Promise.reject(error);
            }
        },

        async dedupeExistingAssetsByHashKeepNewest() {
            const all = await this.idbGetAll('assets');
            for (const rec of all) {
                if (!rec.hash && rec.full) {
                    try {
                        if (!(rec.full instanceof Blob)) { throw new Error("Asset data is not a valid Blob."); }
                        rec.hash = await this.sha256Hex(rec.full);
                        await this.idbPut(rec, 'assets');
                    } catch (error) {
                        console.error(`A corrupted or invalid asset record (ID: ${rec.id}) was detected and will be deleted.`, { record: rec, error: error });
                        if (rec.id) { await this.idbDelete(rec.id, 'assets'); }
                    }
                }
            }
            const byHash = new Map();
            const cleanAssets = await this.idbGetAll('assets'); 
            for (const rec of cleanAssets) {
                if (!rec.hash) continue;
                const best = byHash.get(rec.hash);
                if (!best || rec.createdAt > best.createdAt) { byHash.set(rec.hash, rec); }
            }
            for (const rec of cleanAssets) {
                if (rec.hash && byHash.has(rec.hash) && byHash.get(rec.hash).id !== rec.id) {
                    await this.idbDelete(rec.id, 'assets');
                }
            }
            await this.renderLocalAssetPalette_IDB();
            await this.renderLocalBackgroundPalette_IDB();
        },

        async toBlobFromDataURL(dataURL) { const res = await fetch(dataURL); return await res.blob(); },

        async createThumbBlob(imgBlob, max = 256, type = 'image/webp', quality = 0.8) {
            try {
                const bmp = await createImageBitmap(imgBlob);
                const scale = Math.min(max / bmp.width, max / bmp.height, 1);
                const w = Math.round(bmp.width * scale);
                const h = Math.round(bmp.height * scale);
                const c = new OffscreenCanvas(w, h);
                c.getContext('2d').drawImage(bmp, 0, 0, w, h);
                return await c.convertToBlob({ type, quality });
            } catch (e) {
                console.error("Could not create thumbnail from blob, possibly a non-image type.", e);
                return await (await fetch('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8Xw8AAmMBb3eGmC0AAAAASUVORK5CYII=')).blob();
            }
        },
        
        async saveAssetToLibrary({ blob, mime, hash, kind = 'asset' }) {
            const thumbBlob = await this.createThumbBlob(blob);
            const db = await this.idbOpen();
            const tx = db.transaction('assets', 'readwrite');
            const store = tx.objectStore('assets');
            const record = { full: blob, thumb: thumbBlob, mime, createdAt: Date.now(), hash, kind, isFavorite: false };
            store.add(record);
            const getAllReq = store.getAll();
            await new Promise((resolve, reject) => { tx.oncomplete = resolve; tx.onerror = reject; });
            const freshAssets = getAllReq.result;
            this.renderLocalAssetPalette_IDB(freshAssets);
            this.renderLocalBackgroundPalette_IDB(freshAssets);
            if (this.dom.projectLibraryPopupOverlay.classList.contains('visible')) {
                await this.populateProjectLibraryPopup();
            }
            return hash;
        },
        
        async enforceQuota(limitBytes) {
            const assets = await this.idbGetAll('assets');
            let totalBytes = assets.reduce((sum, r) => sum + (r.full?.size || 0) + (r.thumb?.size || 0), 0);
            if (totalBytes <= limitBytes) return;
            const nonFavorites = assets.filter(a => !a.isFavorite);
            nonFavorites.sort((a, b) => a.createdAt - b.createdAt);
            for (const rec of nonFavorites) {
                if (totalBytes <= limitBytes) break;
                await this.idbDelete(rec.id, 'assets');
                totalBytes -= (rec.full?.size || 0) + (rec.thumb?.size || 0);
                this.toast('Oldest non-favorite asset removed to free space.', 3000);
            }
        },
        
        async deleteAssetFromLibrary(assetId) {
            try {
                const idNum = typeof assetId === 'string' ? Number(assetId) : assetId;
                if (!Number.isFinite(idNum)) throw new Error(`Invalid asset id: ${assetId}`);
                await this.idbDelete(idNum, 'assets');
                this.toast('Asset removed from folder.', 1500);
                await this.renderLocalAssetPalette_IDB();
                await this.renderLocalBackgroundPalette_IDB();
                if (this.dom.projectLibraryPopupOverlay.classList.contains('visible')) { await this.populateProjectLibraryPopup(); }
            } catch (error) {
                console.error("Failed to delete asset:", error);
                this.toast("Error: Could not delete asset.", 4000);
            }
        },

        async renderLocalAssetPalette_IDB(assets) {
            const all = assets || await this.idbGetAll('assets');
            const assetsOnly = all.filter(r => (r.kind || 'asset') === 'asset').sort((a, b) => b.createdAt - a.createdAt);
            this.dom.localAssetPalette.innerHTML = '';
            
            const toShow = assetsOnly.slice(0, 4);

            toShow.forEach((asset, index) => {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb';
                thumb.title = "Add asset as a new layer";
                
                const thumbUrl = URL.createObjectURL(asset.thumb);
                const img = new Image();
                img.src = thumbUrl;
                img.onload = () => URL.revokeObjectURL(thumbUrl);
                thumb.appendChild(img);
                
                thumb.addEventListener('click', () => {
                    if (!this.state.canvasState.backgroundElement) { this.toast('Please set a background before adding layers.', 2000); return; }
                    this.addImageLayer(URL.createObjectURL(asset.full), asset.hash, true);
                });

                if (index === toShow.length - 1) {
                    const addAssetBtn = document.createElement('button');
                    addAssetBtn.className = 'palette-overlay-btn';
                    addAssetBtn.innerHTML = '+';
                    addAssetBtn.title = "Add a new image asset";
                    addAssetBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.openAddLayerPopup();
                    });
                    thumb.appendChild(addAssetBtn);
                }
                
                this.dom.localAssetPalette.appendChild(thumb);
            });

            if (assetsOnly.length === 0) {
                this.dom.localAssetPalette.innerHTML = `<p class="placeholder-text" style="padding:0;line-height:1.2;">Your recent assets will appear here.</p>`;
                const addAssetBtn = document.createElement('button');
                addAssetBtn.className = 'palette-slot empty';
                addAssetBtn.innerHTML = '+';
                addAssetBtn.title = 'Add a new image asset';
                addAssetBtn.addEventListener('click', () => this.openAddLayerPopup());
                this.dom.localAssetPalette.appendChild(addAssetBtn);
            }
        },

        async renderLocalBackgroundPalette_IDB(assets) {
            const all = assets || await this.idbGetAll('assets');
            const backgroundsOnly = all.filter(r => (r.kind || 'asset') === 'background').sort((a, b) => b.createdAt - a.createdAt);
            this.dom.localBackgroundPalette.innerHTML = '';
            
            const toShow = backgroundsOnly.slice(0, 4);

            toShow.forEach((bg, index) => {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb';
                thumb.title = "Set as background";
                
                const thumbUrl = URL.createObjectURL(bg.thumb);
                const img = new Image();
                img.src = thumbUrl;
                img.onload = () => URL.revokeObjectURL(thumbUrl);
                thumb.appendChild(img);
                
                thumb.addEventListener('click', () => {
                    const fullUrl = URL.createObjectURL(bg.full);
                    const fullImage = new Image();
                    fullImage.onload = () => { this.setBackground(fullImage, bg.hash); URL.revokeObjectURL(fullUrl); };
                    fullImage.onerror = () => { this.toast('Error loading this background.'); URL.revokeObjectURL(fullUrl); }
                    fullImage.src = fullUrl;
                });

                if (index === toShow.length - 1) {
                    const addBgBtn = document.createElement('button');
                    addBgBtn.className = 'palette-overlay-btn';
                    addBgBtn.innerHTML = '+';
                    addBgBtn.title = "Add or change background";
                    addBgBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.openAddLayerPopup('background');
                    });
                    thumb.appendChild(addBgBtn);
                }
                
                this.dom.localBackgroundPalette.appendChild(thumb);
            });

            if (toShow.length === 0) {
                 const addBgBtn = document.createElement('button');
                 addBgBtn.className = 'palette-slot empty';
                 addBgBtn.innerHTML = '+';
                 addBgBtn.title = "Add or change background";
                 addBgBtn.addEventListener('click', () => this.dom.initialBackgroundInput.click());
                 this.dom.localBackgroundPalette.appendChild(addBgBtn);
            }
        },

        setLocalFolderTab(tab) {
            const isProjects = tab === 'projects', isAssets = tab === 'assets', isBackgrounds = tab === 'backgrounds', isFavorites = tab === 'favorites';
            this.dom.libraryTabProjectsBtn.classList.toggle('active', isProjects);
            this.dom.libraryTabAssetsBtn.classList.toggle('active', isAssets);
            this.dom.libraryTabBackgroundsBtn.classList.toggle('active', isBackgrounds);
            this.dom.libraryTabFavoritesBtn.classList.toggle('active', isFavorites);
            this.dom.projectLibraryGridProjects.classList.toggle('hidden', !isProjects);
            this.dom.projectLibraryGridAssets.classList.toggle('hidden', !isAssets);
            this.dom.projectLibraryGridBackgrounds.classList.toggle('hidden', !isBackgrounds);
            this.dom.projectLibraryGridFavorites.classList.toggle('hidden', !isFavorites);
        },

        switchAndSaveLibraryTab(tabId) {
            this.setLocalFolderTab(tabId);
            localStorage.setItem('ims-last-library-tab', tabId);
        },
        
        async deleteProjectFromLibrary(projectId) {
            await this.idbDelete(projectId, 'projects');
            this.toast('Project deleted from library.', 2000);
            await this.populateProjectLibraryPopup();
        },

        async loadProjectFromLibrary(projectId) {
            if (this.isCanvasDirty()) {
                this.state.pendingProjectId = projectId;
                this.dom.saveChangesOverlay.classList.add('visible');
            } else {
                await this._actuallyLoadProject(projectId);
            }
        },

       async populateProjectLibraryPopup() {
            const allAssets = await this.idbGetAll('assets');
            const createAssetGridItem = async (rec, onClick, context = 'recents') => {
                const item = document.createElement('div');
                item.className = 'library-grid-item';
                item.dataset.assetId = String(rec.id);
                const content = document.createElement('div');
                const thumbUrl = URL.createObjectURL(rec.thumb);
                const img = document.createElement('img');
                img.src = thumbUrl;
                img.alt = rec.kind;
                img.onload = () => { URL.revokeObjectURL(thumbUrl); };
                content.appendChild(img);
                content.addEventListener('click', () => { onClick(rec); this.dom.projectLibraryPopupOverlay.classList.remove('visible'); });
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerHTML = '&times;';
                const favoriteBtn = document.createElement('button');
                favoriteBtn.className = 'favorite-btn';
                favoriteBtn.classList.toggle('is-favorite', !!rec.isFavorite);
                favoriteBtn.title = rec.isFavorite ? 'Remove from favorites' : 'Add to favorites';
                if (context === 'favorites') {
                    deleteBtn.style.display = 'none';
                    favoriteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.openConfirmationModal('Remove this from your favorites?', async () => {
                           const assetToUpdate = await this.idbGet(rec.id, 'assets');
                           assetToUpdate.isFavorite = false;
                           await this.idbPut(assetToUpdate, 'assets');
                           this.toast('Removed from favorites.', 2000);
                           await this.populateProjectLibraryPopup();
                           this.closeConfirmationModal();
                        });
                    });
                } else {
                    deleteBtn.title = `Permanently delete from storage`;
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.openConfirmationModal('Permanently delete this item?', async () => {
                            await this.deleteAssetFromLibrary(rec.id);
                            this.closeConfirmationModal();
                        });
                    });
                    favoriteBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const assetToUpdate = await this.idbGet(rec.id, 'assets');
                        assetToUpdate.isFavorite = !assetToUpdate.isFavorite;
                        await this.idbPut(assetToUpdate, 'assets');
                        await this.populateProjectLibraryPopup();
                        this.toast(assetToUpdate.isFavorite ? `${assetToUpdate.kind.charAt(0).toUpperCase() + assetToUpdate.kind.slice(1)} added to favorites!` : 'Removed from favorites.', 2000);
                    });
                }
                item.appendChild(content);
                item.appendChild(deleteBtn);
                item.appendChild(favoriteBtn);
                return item;
            };

            const assets = allAssets.filter(r => (r.kind || 'asset') === 'asset').sort((a,b) => b.createdAt - a.createdAt);
            const bgs = allAssets.filter(r => r.kind === 'background').sort((a,b) => b.createdAt - a.createdAt);
            const favoriteAssets = allAssets.filter(r => r.isFavorite && (r.kind || 'asset') === 'asset').sort((a,b) => b.createdAt - a.createdAt);
            const favoriteBgs = allAssets.filter(r => r.isFavorite && r.kind === 'background').sort((a,b) => b.createdAt - a.createdAt);
            const allProjects = await this.idbGetAll('projects');

            this.dom.projectLibraryGridAssets.innerHTML = '<h5>Recent Assets</h5>';
            if (assets.length === 0) {
                this.dom.projectLibraryGridAssets.innerHTML = `<div class="empty-library-placeholder"><i class="fas fa-image"></i><h3>No Recent Assets</h3><p>Assets you add to your creations will appear here for re-use.</p></div>`;
            } else {
                for (const rec of assets) this.dom.projectLibraryGridAssets.appendChild(await createAssetGridItem(rec, r => {
                    if (!this.state.canvasState.backgroundElement) { this.toast('Please set a background before adding layers.', 2000); return; }
                    this.addImageLayer(URL.createObjectURL(r.full), r.hash, true);
                }));
            }

            this.dom.projectLibraryGridBackgrounds.innerHTML = '<h5>Recent Backgrounds</h5>';
            if (bgs.length === 0) {
                this.dom.projectLibraryGridBackgrounds.innerHTML = `<div class="empty-library-placeholder"><i class="fas fa-panorama"></i><h3>No Recent Backgrounds</h3><p>The backgrounds you use in your projects will be automatically saved here.</p></div>`;
            } else {
                for(const rec of bgs) this.dom.projectLibraryGridBackgrounds.appendChild(await createAssetGridItem(rec, r => {
                    const fullUrl = URL.createObjectURL(r.full);
                    const imgEl = new Image();
                    imgEl.onload = () => { this.setBackground(imgEl, r.hash); URL.revokeObjectURL(fullUrl); };
                    imgEl.onerror = () => { URL.revokeObjectURL(fullUrl); this.toast('Could not load background image.', 3000); };
                    imgEl.src = fullUrl;
                }));
            }

            this.dom.projectLibraryGridFavorites.innerHTML = '';
            if (favoriteAssets.length > 0) {
                 this.dom.projectLibraryGridFavorites.insertAdjacentHTML('beforeend', '<h5>Favorite Assets</h5>');
                 for(const rec of favoriteAssets) this.dom.projectLibraryGridFavorites.appendChild(await createAssetGridItem(rec, r => {
                    if (!this.state.canvasState.backgroundElement) { this.toast('Please set a background before adding layers.', 2000); return; }
                    this.addImageLayer(URL.createObjectURL(r.full), r.hash, true);
                }, 'favorites'));
            }
            if (favoriteBgs.length > 0) {
                 this.dom.projectLibraryGridFavorites.insertAdjacentHTML('beforeend', '<h5>Favorite Backgrounds</h5>');
                 for(const rec of favoriteBgs) this.dom.projectLibraryGridFavorites.appendChild(await createAssetGridItem(rec, r => {
                    const fullUrl = URL.createObjectURL(r.full);
                    const imgEl = new Image();
                    imgEl.onload = () => { this.setBackground(imgEl, r.hash); URL.revokeObjectURL(fullUrl); };
                    imgEl.onerror = () => { URL.revokeObjectURL(fullUrl); this.toast('Could not load background image.', 3000); };
                    imgEl.src = fullUrl;
                }, 'favorites'));
            }
            if (favoriteAssets.length === 0 && favoriteBgs.length === 0) {
                this.dom.projectLibraryGridFavorites.innerHTML = `<div class="empty-library-placeholder"><i class="fas fa-star"></i><h3>Your Favorites are Empty</h3><p>Click the star icon on any asset or background to save it here for quick access.</p></div>`;
            }

            this.dom.projectLibraryGridProjects.innerHTML = '<h5>Saved Projects</h5>';
            if (allProjects.length === 0) {
                this.dom.projectLibraryGridProjects.innerHTML = `<div class="empty-library-placeholder"><i class="fas fa-save"></i><h3>No Saved Projects</h3><p>Click the 'Save Project' button on the main screen to save your work here.</p></div>`;
            } else {
                allProjects.sort((a, b) => b.createdAt - a.createdAt).forEach(rec => {
                    const item = document.createElement('div');
                    item.className = 'library-grid-item';
                    item.dataset.projectId = String(rec.id);
                    const content = document.createElement('div');
                    const thumbUrl = URL.createObjectURL(rec.thumbnail);
                    content.innerHTML = `<img src="${thumbUrl}" alt="Saved Project">`;
                    content.addEventListener('click', () => this.loadProjectFromLibrary(rec.id));
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.title = `Delete project`;
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.openConfirmationModal('Permanently delete this project?', async () => {
                            await this.deleteProjectFromLibrary(rec.id);
                            this.closeConfirmationModal();
                        });
                    });
                    item.appendChild(content);
                    item.appendChild(deleteBtn);
                    this.dom.projectLibraryGridProjects.appendChild(item);
                });
            }
        },

       async handleFileUpload(file, intendedUse = 'asset') {
            if (!file || !file.type.startsWith('image/')) {
                this.toast('Unsupported file type. Please use an image.');
                return;
            }
            this.toast('Processing image...', null);
            const optimizedBlob = await this.createOptimizedBlob(file);
            const blobHash = await this.sha256Hex(optimizedBlob);
            const existingAssets = await this.idbFindByHash(blobHash);
            if (existingAssets.length > 0) {
                this.hideToast();
                const record = existingAssets[0];
                const url = URL.createObjectURL(record.full);
                const img = new Image();
                img.onload = () => {
                    if (intendedUse === 'background') this.setBackground(img, blobHash);
                    else this.addImageLayer(img.src, blobHash, true);
                    URL.revokeObjectURL(url);
                };
                img.src = url;
                return;
            }
            await this.saveAssetToLibrary({ blob: optimizedBlob, mime: optimizedBlob.type, hash: blobHash, kind: intendedUse });
            const tempUrl = URL.createObjectURL(optimizedBlob);
            const imageEl = new Image();
            imageEl.onload = () => {
                if (intendedUse === 'background') this.setBackground(imageEl, blobHash);
                else this.addImageLayer(imageEl.src, blobHash, true);
                this.hideToast();
            };
            imageEl.src = tempUrl;
        },

        async handleBackgroundUpload(file) { await this.handleFileUpload(file, 'background'); },
        async processUploadedFile(file) { await this.handleFileUpload(file, 'layer'); this.closeAddLayerPopup(); },
        async handleNewAsset(src) {
            if (!this.state.canvasState.backgroundElement) { this.toast('Please set a background before adding layers.', 2000); return; }
            const blob = await this.toBlobFromDataURL(src);
            await this.processUploadedFile(blob);
        },

      calculateContentBounds(canvas) {
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            let minX = canvas.width, minY = canvas.height, maxX = -1, maxY = -1;

            // Using a more robust threshold to ensure faint AI artifacts are ignored.
            const ALPHA_THRESHOLD = 20;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    if (data[(y * canvas.width + x) * 4 + 3] > ALPHA_THRESHOLD) {
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                    }
                }
            }
            if (maxX === -1) {
                return { x: 0, y: 0, width: canvas.width, height: canvas.height, isEmpty: true };
            }
            return { x: minX, y: minY, width: maxX - minX + 1, height: maxY - minY + 1, isEmpty: false };
        },

       
      async addImageLayer(src, hash) {
            if (!this.state.canvasState.backgroundElement) { this.toast('Please add a background image first.', 2000); return; }
            const newLayerObject = await this.createLayerFromSrc(src, { originalHash: hash, type: 'image' });
            this.dispatch({ type: 'LAYER_ADDED', payload: { newLayer: newLayerObject } });
            this.triggerAnimatedRender();
            this.saveState();
        },

        async createLayerFromSrc(src, layerData) {
            const img = new Image();
            img.src = src;
            await img.decode();

            let isOptimized = false;
            if (layerData.originalHash) {
                const assets = await this.idbFindByHash(layerData.originalHash);
                if (assets.length > 0 && assets[0].mime === 'image/webp') {
                    isOptimized = true;
                }
            }

            const MAX_PROXY_DIMENSION = 2048;
            const w = img.naturalWidth || 0, h = img.naturalHeight || 0;
            let proxyW = w, proxyH = h;
            if (proxyW > MAX_PROXY_DIMENSION || proxyH > MAX_PROXY_DIMENSION) {
                if (w > h) { proxyW = MAX_PROXY_DIMENSION; proxyH = Math.round((h / w) * MAX_PROXY_DIMENSION); } 
                else { proxyH = MAX_PROXY_DIMENSION; proxyW = Math.round((w / h) * MAX_PROXY_DIMENSION); }
            }
            const proxyCanvas = document.createElement('canvas');
            proxyCanvas.width = proxyW; proxyCanvas.height = proxyH;
            const proxyCtx = proxyCanvas.getContext('2d', { willReadFrequently: true });
            proxyCtx.drawImage(img, 0, 0, proxyW, proxyH);
            const contentFrame = this.calculateContentBounds(proxyCanvas);
            const newLayer = {
                id: layerData.id || (Date.now() + Math.random()).toString(),
                originalHash: layerData.originalHash,
                type: 'image',
                x: layerData.x !== undefined ? layerData.x : this.dom.movieCanvas.width / 2,
                y: layerData.y !== undefined ? layerData.y : this.dom.movieCanvas.height / 2,
                size: layerData.size !== undefined ? layerData.size : Math.max(20, Math.min(this.dom.movieCanvas.width, this.dom.movieCanvas.height) * 0.4),
                rot: layerData.rot || 0,
                flipX: layerData.flipX || false,
                opacity: layerData.opacity || 1,
                brightness: layerData.brightness || 1,
                saturation: layerData.saturation || 1,
                shadow: layerData.shadow || { enabled: false, color: '#000000', blur: 10, offsetX: 10, offsetY: 10 },
                border: layerData.border || { enabled: false, color: '#FFFFFF', width: 4 },
                createdAt: Date.now(),
                asset: img,
                proxyCanvas: proxyCanvas,
                proxyCtx: proxyCtx,
                contentFrame: contentFrame,
                src: src,
                isOptimized: isOptimized // This line fixes the issue
            };
            newLayer.propX = newLayer.x / this.dom.movieCanvas.width;
            newLayer.propY = newLayer.y / this.dom.movieCanvas.height;
            newLayer.propSize = newLayer.size / this.dom.movieCanvas.width;
            return newLayer;
        },


        updateControlsState() {
            const hasBackground = !!this.state.canvasState.backgroundElement;
            this.dom.downloadImageBtn.disabled = !hasBackground;
            this.dom.saveProjectBtn.disabled = !hasBackground;
            this.dom.clearCanvasBtn.disabled = !hasBackground;
            this.dom.visualsBtn.disabled = !hasBackground;
            this.dom.textBtn.disabled = !hasBackground;
            this.dom.eraseToolBtn.disabled = !hasBackground;
            this.dom.aiToolsBtn.disabled = !hasBackground;
            this.dom.addNewTextLayerBtn.disabled = !hasBackground;
            this.renderLayerPalette();
            this.renderTextLayerPalette();
        },

      setBackground(element, hash, isRestoring = false) {
            // This function is now called for BOTH new user actions AND when restoring state.
            // The 'isRestoring' flag is the key.

            if (!isRestoring) {
                // A user initiated this change. Reset the filters locally.
                this.state.canvasState.bgBrightness = 1;
                this.state.canvasState.bgSaturation = 1;
                this.updateBackgroundVisualsUI();
            }

            const isFirstBackground = !this.state.canvasState.backgroundElement;
            this.state.canvasState.backgroundElement = element;
            this.state.canvasState.backgroundType = 'image';
            this.state.canvasState.backgroundHash = hash; // Directly update the hash in the state
            this.state.canvasState.dominantColor = this.getDominantColor(element);
            this.updateCanvasPanelBackground();
            
            const w = element.naturalWidth, h = element.naturalHeight;
            const MIN_CANVAS_SIDE = 1280;
            let canvasW = w, canvasH = h;
            if (w < MIN_CANVAS_SIDE || h < MIN_CANVAS_SIDE) {
                const ratio = w / h;
                if (ratio < 1) { canvasW = MIN_CANVAS_SIDE; canvasH = MIN_CANVAS_SIDE / ratio; }
                else { canvasH = MIN_CANVAS_SIDE; canvasW = MIN_CANVAS_SIDE * ratio; }
            }
            this.state.masterWidth = w; this.state.masterHeight = h;
            const newCanvasWidth = Math.round(canvasW), newCanvasHeight = Math.round(canvasH);
            this.dom.movieCanvas.width = this.dom.controlsOverlayCanvas.width = newCanvasWidth;
            this.dom.movieCanvas.height = this.dom.controlsOverlayCanvas.height = newCanvasHeight;
            
            if (!isFirstBackground && this.state.canvasState.layers.length > 0) {
                this.toast('Adapting layers to new background...', 2000);
                this.state.canvasState.layers.forEach(l => {
                    l.x = l.propX * this.dom.movieCanvas.width;
                    l.y = l.propY * this.dom.movieCanvas.height;
                    if (l.type === 'image') { l.size = l.propSize * this.dom.movieCanvas.width; }
                    else if (l.type === 'text') { l.fontSize = l.propSize * this.dom.movieCanvas.height; }
                });
            }
            
            this.resizeCanvas();
            this.updateControlsState();
            this.updateEditPanelsUI();
            
            let startTime = null;
            const animateBackground = (currentTime) => {
                if (!startTime) startTime = currentTime;
                const progress = Math.min((currentTime - startTime) / 500, 1);
                if (!this.dom.canvasPlaceholder.classList.contains('hidden')) { this.dom.canvasPlaceholder.classList.add('hidden'); }
                this.dom.movieCtx.clearRect(0, 0, this.dom.movieCanvas.width, this.dom.movieCanvas.height);
                this.dom.movieCtx.save();
                this.dom.movieCtx.globalAlpha = progress;
                this.dom.movieCtx.filter = `brightness(${this.state.canvasState.bgBrightness}) saturate(${this.state.canvasState.bgSaturation})`;
                this.dom.movieCtx.drawImage(this.state.canvasState.backgroundElement, 0, 0, this.dom.movieCanvas.width, this.dom.movieCanvas.height);
                this.dom.movieCtx.restore();
                this.drawLayers(this.dom.movieCtx, this.state.canvasState.layers);
                this.drawControlsOverlay();
                if (progress < 1) { requestAnimationFrame(animateBackground); } 
                else { this.drawFrame(); }
            };
            requestAnimationFrame(animateBackground);

            if (isFirstBackground && !isRestoring) {
                this.toast('Background set! Add layers to create your image.', 3000);
            }

            if (!isRestoring) {
                // IF this was a new action by the user, dispatch it now AFTER doing the work.
                this.dispatch({
                    type: 'BACKGROUND_CHANGED',
                    payload: { backgroundHash: hash }
                });
                this.saveState();
            }
        },
        
        resizeCanvas() {
            const panelWidth = this.dom.canvasPanel.clientWidth, panelHeight = this.dom.canvasPanel.clientHeight;
            if (panelWidth === 0 || panelHeight === 0) return;
            const canvasAspectRatio = this.dom.movieCanvas.width / this.dom.movieCanvas.height;
            let displayWidth, displayHeight;
            if (panelWidth / panelHeight > canvasAspectRatio) { displayHeight = panelHeight; displayWidth = displayHeight * canvasAspectRatio; } 
            else { displayWidth = panelWidth; displayHeight = displayWidth / canvasAspectRatio; }
            const topOffset = (panelHeight - displayHeight) / 2, leftOffset = (panelWidth - displayWidth) / 2;
            [this.dom.movieCanvas, this.dom.controlsOverlayCanvas].forEach(c => {
                c.style.width = `${displayWidth}px`; c.style.height = `${displayHeight}px`;
                c.style.position = 'absolute'; c.style.top = `${topOffset}px`; c.style.left = `${leftOffset}px`;
            });
            this.dom.pasteboardOverlayCanvas.width = this.dom.movieCanvas.width + this.config.PASTEBOARD_MARGIN * 2;
            this.dom.pasteboardOverlayCanvas.height = this.dom.movieCanvas.height + this.config.PASTEBOARD_MARGIN * 2;
            const scaleFactor = displayWidth / this.dom.movieCanvas.width;
            this.dom.pasteboardOverlayCanvas.style.width = `${this.dom.pasteboardOverlayCanvas.width * scaleFactor}px`;
            this.dom.pasteboardOverlayCanvas.style.height = `${this.dom.pasteboardOverlayCanvas.height * scaleFactor}px`;
            const pasteboardTopOffset = topOffset - (this.config.PASTEBOARD_MARGIN * scaleFactor);
            const pasteboardLeftOffset = leftOffset - (this.config.PASTEBOARD_MARGIN * scaleFactor);
            this.dom.pasteboardOverlayCanvas.style.position = 'absolute';
            this.dom.pasteboardOverlayCanvas.style.top = `${pasteboardTopOffset}px`;
            this.dom.pasteboardOverlayCanvas.style.left = `${pasteboardLeftOffset}px`;
        },
        
        openAddLayerPopup(mode = 'asset') {
            if (mode === 'asset' && !this.state.canvasState.backgroundElement) {
                this.toast('Please set a background before adding layers.', 2000);
                return;
            }
            this.state.addAssetMode = mode;
            const title = this.dom.addLayerOverlay.querySelector('h4');
            const subtitle = this.dom.addLayerOverlay.querySelector('p');
            if (title) title.textContent = 'Add an Image';
            if (subtitle) subtitle.textContent = 'Add your own image to the project.';
            this.dom.addLayerOverlay.classList.add('visible');
        },
        closeAddLayerPopup() { this.dom.addLayerOverlay.classList.remove('visible'); },

        updateLayerInstructions() {
            this.dom.layerInstructions.classList.remove('placeholder-text');
            if (!this.state.canvasState.backgroundElement) { this.dom.layerInstructions.textContent = "Add a background to begin."; this.dom.layerInstructions.classList.add('placeholder-text'); } 
            else if (this.state.canvasState.layers.filter(l => l.type === 'image').length === 0) { this.dom.layerInstructions.textContent = "Click '+' to add your first visual layer."; } 
            else { this.dom.layerInstructions.textContent = "Click & drag layers to re-order them, or use [Q] & [W]."; }
        },

        updateLayerPaletteSelection() {
            this.dom.assetPalette.querySelectorAll('.layer-thumb').forEach(node => {
                node.classList.toggle('active', node.dataset.layerId === this.state.activeLayerId);
            });
        },

        renderTextLayerPalette() {
            this.dom.textLayerPalette.innerHTML = '';
            if (!this.state.canvasState.backgroundElement) return;
            const textLayers = this.state.canvasState.layers.filter(l => l.type === 'text');
            textLayers.forEach(layer => {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb text-thumb';
                thumb.classList.toggle('active', layer.id === this.state.activeLayerId);
                thumb.dataset.layerId = layer.id;
                thumb.title = "Click to select";
                thumb.innerHTML = `<span>${layer.text.split('\n')[0] || "Empty"}</span><div class="layer-controls"><div class="layer-btn delete" title="Delete Layer">x</div></div>`;
                thumb.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (e.target.classList.contains('layer-btn')) return;
                     if (this.state.activeLayerId !== layer.id) this.deactivateEraser();
                    this.state.activeLayerId = layer.id;
                    this.updateLayerPaletteSelection();
                    this.renderTextLayerPalette();
                    this.updateEditPanelsUI();
                    this.drawFrame();
                });
                thumb.querySelector('.delete').onclick = (e) => { e.stopPropagation(); this.deleteMovieLayer(layer.id); };
                this.dom.textLayerPalette.appendChild(thumb);
            });
        },
        
        addDragAndDropHandlers(thumb) {
            thumb.setAttribute('draggable', 'true');
            thumb.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/plain', thumb.dataset.layerId); setTimeout(() => thumb.classList.add('dragging'), 0); });
            thumb.addEventListener('dragend', () => { document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over')); thumb.classList.remove('dragging'); });
            thumb.addEventListener('dragover', (e) => { e.preventDefault(); if (document.querySelector('.dragging') !== thumb) { thumb.classList.add('drag-over'); } });
            thumb.addEventListener('dragleave', () => thumb.classList.remove('drag-over'));
            thumb.addEventListener('drop', (e) => {
                e.preventDefault();
                thumb.classList.remove('drag-over');
                const draggedId = e.dataTransfer.getData('text/plain');
                const droppedOnId = thumb.dataset.layerId;
                if (draggedId === droppedOnId) return;
                const i1 = this.state.canvasState.layers.findIndex(l => l.id.toString() === draggedId);
                const i2 = this.state.canvasState.layers.findIndex(l => l.id.toString() === droppedOnId);
                if (i1 > -1 && i2 > -1) {
                    const [item] = this.state.canvasState.layers.splice(i1, 1);
                    this.state.canvasState.layers.splice(i2, 0, item);
                    this.renderLayerPalette();
                    if(this.updateTextOrderButtonsState) this.updateTextOrderButtonsState();
                    this.drawFrame();
                    this.saveState();
                }
            });
        },
        
       renderLayerPalette() {
            this.updateLayerInstructions();
            const hasBackground = !!this.state.canvasState.backgroundElement;
            const visualLayers = hasBackground ? this.state.canvasState.layers.filter(l => l.type === 'image') : [];
            const existingNodes = new Map();
            this.dom.assetPalette.querySelectorAll('.layer-thumb').forEach(node => {
                existingNodes.set(node.dataset.layerId, node);
            });
            visualLayers.forEach((layer, index) => {
                let thumbNode = existingNodes.get(layer.id);
                if (!thumbNode) {
                    thumbNode = document.createElement('div');
                    thumbNode.className = 'layer-thumb';
                    thumbNode.dataset.layerId = layer.id;
                    const thumbCanvas = document.createElement('canvas');
                    thumbCanvas.width = 60;
                    thumbCanvas.height = 60;
                    thumbNode.appendChild(thumbCanvas);
                    const controls = document.createElement('div');
                    controls.className = 'layer-controls';
                    controls.innerHTML = `<div class="layer-btn delete" title="Delete Layer">x</div>`;
                    thumbNode.appendChild(controls);
                    const optimizationIndicator = document.createElement('div');
                    optimizationIndicator.className = 'optimization-badge';
                    thumbNode.appendChild(optimizationIndicator);
                    this.addDragAndDropHandlers(thumbNode);
                    thumbNode.addEventListener('click', (e) => {
                        if (e.target.classList.contains('layer-btn')) return;
                        if (this.state.activeLayerId !== layer.id) this.deactivateEraser();
                        this.state.activeLayerId = layer.id;
                        this.updateLayerPaletteSelection();
                        this.renderTextLayerPalette();
                        this.updateEditPanelsUI();
                        this.drawFrame();
                    });
                    controls.querySelector('.delete').onclick = (e) => { e.stopPropagation(); this.deleteMovieLayer(layer.id); };
                }
                const currentVersion = layer.contentVersion || 0;
                const nodeVersion = parseInt(thumbNode.dataset.version || -1, 10);
                if (currentVersion > nodeVersion) {
                    const thumbCanvas = thumbNode.querySelector('canvas');
                    const thumbCtx = thumbCanvas.getContext('2d');
                    thumbCtx.clearRect(0, 0, 60, 60);
                    const source = layer.proxyCanvas;
                    const destWidth = 60, destHeight = 60;
                    const sourceWidth = source.width, sourceHeight = source.height;
                    if (sourceWidth === 0 || sourceHeight === 0) return;
                    const sourceRatio = sourceWidth / sourceHeight, destRatio = destWidth / destHeight;
                    let sx = 0, sy = 0, sWidth = sourceWidth, sHeight = sourceHeight;
                    if (sourceRatio > destRatio) {
                        sHeight = sourceHeight; sWidth = sHeight * destRatio; sx = (sourceWidth - sWidth) / 2;
                    } else if (sourceRatio < destRatio) {
                        sWidth = sourceWidth; sHeight = sWidth / destRatio; sy = (sourceHeight - sHeight) / 2;
                    }
                    thumbCtx.drawImage(source, sx, sy, sWidth, sHeight, 0, 0, destWidth, destHeight);
                    thumbNode.dataset.version = currentVersion;
                }
                const optBadge = thumbNode.querySelector('.optimization-badge');
                if (layer.originalHash) {
                    optBadge.style.display = 'flex';
                    optBadge.textContent = layer.isOptimized ? '✓' : '...';
                    optBadge.title = layer.isOptimized ? 'Asset is optimized (WebP)' : 'Optimizing asset...';
                    optBadge.classList.toggle('pending', !layer.isOptimized);
                } else {
                    optBadge.style.display = 'none';
                }
                thumbNode.classList.toggle('active', layer.id === this.state.activeLayerId);
                const expectedNode = this.dom.assetPalette.children[index];
                if (expectedNode !== thumbNode) {
                    this.dom.assetPalette.insertBefore(thumbNode, expectedNode);
                }
                existingNodes.delete(layer.id);
            });
            existingNodes.forEach(node => node.remove());
            let addButton = document.getElementById('add-layer-slot-btn');
            if (!addButton) {
                addButton = document.createElement('button');
                addButton.id = 'add-layer-slot-btn';
                addButton.className = 'palette-slot empty';
                addButton.innerHTML = '+';
                this.dom.assetPalette.appendChild(addButton);
            }
            addButton.title = hasBackground ? 'Add a new image asset' : 'Add a background to enable layers';
            addButton.disabled = !hasBackground;
            if (hasBackground) { addButton.onclick = () => this.openAddLayerPopup(); }
            this.dom.assetPalette.appendChild(addButton);
        },
        
        switchVisualsTab(tabToShow) {
            const isAssetTab = tabToShow === 'asset';
            this.dom.visualsTabAssetBtn.classList.toggle('active', isAssetTab);
            this.dom.visualsTabBackgroundBtn.classList.toggle('active', !isAssetTab);
            this.dom.assetTabPanel.classList.toggle('hidden', !isAssetTab);
            this.dom.backgroundTabPanel.classList.toggle('hidden', isAssetTab);
        },
        
        updateAssetVisualsUI() {
            const activeLayer = this.getActiveLayer();
            if (activeLayer && activeLayer.type === 'image') {
                this.dom.assetVisualsControls.classList.remove('disabled');
                this.dom.assetOpacitySlider.value = activeLayer.opacity;
                this.dom.assetBrightnessSlider.value = activeLayer.brightness;
                this.dom.assetSaturationSlider.value = activeLayer.saturation;
                document.getElementById('shadow-enable').checked = activeLayer.shadow.enabled;
                document.getElementById('shadow-controls').classList.toggle('disabled', !activeLayer.shadow.enabled);
                document.getElementById('shadow-color').value = activeLayer.shadow.color;
                document.getElementById('shadow-blur').value = activeLayer.shadow.blur;
                document.getElementById('shadow-offset-x').value = activeLayer.shadow.offsetX;
                document.getElementById('shadow-offset-y').value = activeLayer.shadow.offsetY;
                document.getElementById('asset-edge-enable').checked = activeLayer.border.enabled;
                document.getElementById('asset-edge-controls').classList.toggle('disabled', !activeLayer.border.enabled);
                document.getElementById('asset-edge-color').value = activeLayer.border.color;
                document.getElementById('asset-edge-width').value = activeLayer.border.width;
            } else {
                this.dom.assetVisualsControls.classList.add('disabled');
            }
        },
        
        populateCustomFontSelector() {
            this.dom.fontSelectList.innerHTML = '';
            this.config.availableFonts.sort((a, b) => a.name.localeCompare(b.name));
            this.config.availableFonts.forEach(font => {
                const li = document.createElement('li');
                li.textContent = font.name;
                li.dataset.fontValue = font.value;
                li.style.fontFamily = font.value;
                if (font.style) { li.setAttribute('style', `font-family: ${font.value}; ${font.style}`); }
                li.addEventListener('mouseenter', (e) => this.handleFontHoverPreview(e));
                li.addEventListener('click', (e) => this.handleFontSelect(e));
                this.dom.fontSelectList.appendChild(li);
            });
        },

        handleFontHoverPreview(e) {
            const activeLayer = this.getActiveLayer();
            if (!activeLayer || activeLayer.type !== 'text') return;
            if (this.state.originalFontOnHover === null) { this.state.originalFontOnHover = activeLayer.font; }
            activeLayer.font = e.target.dataset.fontValue;
            if (!this.state.movieInteraction.active) this.drawFrame();
        },

        handleFontHoverEnd() {
            const activeLayer = this.getActiveLayer();
            if (this.state.originalFontOnHover && activeLayer && activeLayer.type === 'text') {
                activeLayer.font = this.state.originalFontOnHover;
                this.state.originalFontOnHover = null;
                if (!this.state.movieInteraction.active) this.drawFrame();
            }
        },

       handleFontSelect(e) {
            const activeLayer = this.getActiveLayer();
            const newFontValue = e.target.dataset.fontValue;
            if (activeLayer && activeLayer.type === 'text') {
                this.dispatch({
                    type: 'LAYER_PROPERTY_CHANGED',
                    payload: {
                        layerId: activeLayer.id,
                        property: 'font',
                        value: newFontValue
                    }
                });
            }
            this.state.originalFontOnHover = null; 
            this.dom.fontSelectTrigger.querySelector('span').textContent = e.target.textContent;
            this.dom.fontSelectTrigger.querySelector('span').style.fontFamily = newFontValue;
            if (this.dom.fontSelectList.querySelector('.selected')) this.dom.fontSelectList.querySelector('.selected').classList.remove('selected');
            e.target.classList.add('selected');
            this.closeFontDropdown();
            this.saveState();
        },

        openFontDropdown() {
            this.dom.customFontSelect.classList.add('open');
            this.dom.fontSelectDropdown.classList.remove('hidden');
            this.state.originalFontOnHover = null;
        },

        closeFontDropdown() {
            if (!this.dom.customFontSelect.classList.contains('open')) return;
            this.handleFontHoverEnd();
            this.dom.customFontSelect.classList.remove('open');
            this.dom.fontSelectDropdown.classList.add('hidden');
        },

        updateTextVisualsUI() {
            const activeLayer = this.getActiveLayer();
            if (activeLayer && activeLayer.type === 'text') {
                this.dom.textVisualsControls.classList.remove('disabled');
                this.dom.textContentInput.value = activeLayer.text;
                this.dom.textSizeSlider.value = activeLayer.fontSize;
                this.dom.textColorInput.value = activeLayer.color;
                this.dom.textEdgeColorInput.value = activeLayer.strokeColor;
                this.dom.textEdgeWidthSlider.value = activeLayer.strokeWidth;
                document.getElementById('text-shadow-enable').checked = activeLayer.shadow.enabled;
                document.getElementById('text-shadow-controls').classList.toggle('disabled', !activeLayer.shadow.enabled);
                document.getElementById('text-shadow-color').value = activeLayer.shadow.color;
                document.getElementById('text-shadow-blur').value = activeLayer.shadow.blur;
                document.getElementById('text-shadow-offset-x').value = activeLayer.shadow.offsetX;
                document.getElementById('text-shadow-offset-y').value = activeLayer.shadow.offsetY;
                const fontName = this.config.availableFonts.find(f => f.value === activeLayer.font)?.name || 'Select Font';
                const fontValue = activeLayer.font;
                this.dom.fontSelectTrigger.querySelector('span').textContent = fontName;
                this.dom.fontSelectTrigger.querySelector('span').style.fontFamily = fontValue;
                if (this.dom.fontSelectList.querySelector('.selected')) this.dom.fontSelectList.querySelector('.selected').classList.remove('selected');
                const liToSelect = this.dom.fontSelectList.querySelector(`[data-font-value="${fontValue}"]`);
                if (liToSelect) liToSelect.classList.add('selected');
            } else {
                this.dom.textVisualsControls.classList.add('disabled');
            }
        },

        updateBackgroundVisualsUI() {
            this.dom.bgBrightnessSlider.value = this.state.canvasState.bgBrightness;
            this.dom.bgSaturationSlider.value = this.state.canvasState.bgSaturation;
        },

        updateEditPanelsUI() {
            this.updateAssetVisualsUI();
            this.updateTextVisualsUI();
            this.updateBackgroundVisualsUI();
            this.updateTextOrderButtonsState();
            document.querySelectorAll('.control-panel input[type="range"]').forEach(slider => this.updateSliderFill(slider));
        },

    addTextLayer() {
            if (!this.state.canvasState.backgroundElement) { this.toast('Add a background first.', 2000); return; }
            const newFontSize = Math.max(20, Math.min(this.dom.movieCanvas.width, this.dom.movieCanvas.height) * 0.15);
            const newTextLayer = {
                id: (Date.now() + Math.random()).toString(),
                type: 'text',
                text: 'New Text',
                font: "'VT323', monospace",
                fontSize: newFontSize,
                color: '#FFFFFF',
                strokeColor: '#000000',
                strokeWidth: 0,
                x: this.dom.movieCanvas.width / 2,
                y: this.dom.movieCanvas.height / 2,
                rot: 0,
                flipX: false,
                opacity: 1, brightness: 1, saturation: 1,
                width: 0, height: 0,
                shadow: { enabled: false, color: '#000000', blur: 10, offsetX: 10, offsetY: 10 },
                border: { enabled: false, color: '#FFFFFF', width: 4 },
                createdAt: Date.now()
            };
            newTextLayer.propX = newTextLayer.x / this.dom.movieCanvas.width;
            newTextLayer.propY = newTextLayer.y / this.dom.movieCanvas.height;
            newTextLayer.propSize = newTextLayer.fontSize / this.dom.movieCanvas.height;

            this.dispatch({ type: 'LAYER_ADDED', payload: { newLayer: newTextLayer } });
            
            // --- THIS IS THE FIX ---
            // After adding the layer and setting it as active, explicitly update the UI.
            this.updateEditPanelsUI(); 
            
            this.triggerAnimatedRender();
            this.saveState();
        },

        deleteMovieLayer(layerId) {
            this.dispatch({ type: 'LAYER_DELETED', payload: { layerId } });
            
            this.renderLayerPalette();
            this.renderTextLayerPalette();
            this.updateControlsState();
            this.updateEditPanelsUI();
            this.saveState();
        },
        
        getTextBlockMetrics(ctx, text, font, fontSize) {
            ctx.save();
            ctx.font = `${fontSize}px ${font}`;
            const lines = text.split('\n');
            let maxWidth = 0;
            const metrics = ctx.measureText('Ag'); 
            const singleLineHeight = (metrics.actualBoundingBoxAscent || fontSize * 0.8) + (metrics.actualBoundingBoxDescent || fontSize * 0.2);
            lines.forEach(line => { const lineWidth = ctx.measureText(line).width; if (lineWidth > maxWidth) maxWidth = lineWidth; });
            const totalHeight = lines.length * singleLineHeight;
            ctx.restore();
            return { lines, lineHeight: singleLineHeight, maxWidth, totalHeight };
        },
        
        nudgeLayerZ(layerId, delta) {
            const i = this.state.canvasState.layers.findIndex(l => l.id === layerId);
            if (i === -1) return false;
            const j = i + delta;
            if (j < 0 || j >= this.state.canvasState.layers.length) return false;
            const [item] = this.state.canvasState.layers.splice(i, 1);
            this.state.canvasState.layers.splice(j, 0, item);
            return true;
        },

        drawLayers(ctx, layers, isFinalRender = false) {
             for (let i = layers.length - 1; i >= 0; i--) {
                const l = layers[i];
                ctx.save();
                const age = Date.now() - l.createdAt;
                let animationProgress = 1;
                if (!isFinalRender && age < this.config.FADE_IN_DURATION) { animationProgress = age / this.config.FADE_IN_DURATION; }
                const filters = `brightness(${l.brightness}) saturate(${l.saturation})`;
                const shadow = l.shadow.enabled ? `drop-shadow(${l.shadow.offsetX}px ${l.shadow.offsetY}px ${l.shadow.blur}px ${l.shadow.color})` : '';
                let borderFilters = '';
                if (l.type === 'image' && l.border.enabled && l.border.width > 0) { const w = l.border.width, c = l.border.color; borderFilters = `drop-shadow(${w}px ${w}px 0 ${c}) drop-shadow(-${w}px -${w}px 0 ${c}) drop-shadow(-${w}px ${w}px 0 ${c}) drop-shadow(${w}px -${w}px 0 ${c})`; }
                ctx.filter = `${borderFilters} ${shadow} ${filters}`.trim();
                ctx.globalAlpha = l.opacity * animationProgress;
                ctx.translate(l.x, l.y);
                ctx.rotate(l.rot * Math.PI / 180);
                const scaleFactor = 0.95 + 0.05 * animationProgress;
                if (animationProgress < 1) { ctx.scale(scaleFactor, scaleFactor); }
                if (l.flipX) ctx.scale(-1, 1);
                if (l.type === 'image') {
                    const assetToDraw = isFinalRender ? l.asset : l.proxyCanvas;
                    const assetWidth = assetToDraw.width || assetToDraw.naturalWidth;
                    const assetHeight = assetToDraw.height || assetToDraw.naturalHeight;
                    if (assetWidth > 0) { 
                        const dWidth = l.size;
                        const dHeight = l.size * (assetHeight / assetWidth);
                        ctx.drawImage(assetToDraw, -dWidth / 2, -dHeight / 2, dWidth, dHeight); 
                    }
                } else if (l.type === 'text') {
                    ctx.font = `${l.fontSize}px ${l.font}`;
                    ctx.fillStyle = l.color;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    if (l.strokeWidth > 0) { ctx.strokeStyle = l.strokeColor; ctx.lineWidth = l.strokeWidth; }
                    const metrics = this.getTextBlockMetrics(ctx, l.text, l.font, l.fontSize);
                    if (!isFinalRender) { l.width = metrics.maxWidth; l.height = metrics.totalHeight; }
                    const startY = -metrics.totalHeight / 2 + metrics.lineHeight/2;
                    metrics.lines.forEach((line, index) => {
                        const yPos = startY + (index * metrics.lineHeight);
                        if (l.strokeWidth > 0) ctx.strokeText(line, 0, yPos);
                        ctx.fillText(line, 0, yPos);
                    });
                }
                ctx.restore();
            }
        },

        animationRenderLoop() {
            if (!this.state.isAnimatingRender) return;
            const stillAnimating = this.state.canvasState.layers.some(l => (Date.now() - l.createdAt) < this.config.FADE_IN_DURATION);
            if (stillAnimating) { this.drawFrame(); requestAnimationFrame(() => this.animationRenderLoop()); } 
            else { this.state.isAnimatingRender = false; if (!this.state.movieInteraction.active) { this.drawFrame(); } }
        },

        triggerAnimatedRender() {
            if (this.state.isAnimatingRender || this.state.movieInteraction.active) return;
            this.state.isAnimatingRender = true;
            this.animationRenderLoop();
        },

        drawFrame() {
            if (!this.state.canvasState.backgroundElement) { this.dom.movieCtx.clearRect(0, 0, this.dom.movieCanvas.width, this.dom.movieCanvas.height); return; }
            this.dom.movieCtx.clearRect(0, 0, this.dom.movieCanvas.width, this.dom.movieCanvas.height);
            this.dom.movieCtx.save();
            this.dom.movieCtx.filter = `brightness(${this.state.canvasState.bgBrightness}) saturate(${this.state.canvasState.bgSaturation})`;
            this.dom.movieCtx.drawImage(this.state.canvasState.backgroundElement, 0, 0, this.dom.movieCanvas.width, this.dom.movieCanvas.height);
            this.dom.movieCtx.restore();
            this.drawLayers(this.dom.movieCtx, this.state.canvasState.layers);
            this.drawControlsOverlay();
        },
        
        startRenderLoop() { 
            if (this.state.animationFrameId) return; 
            const loop = () => { this.drawFrame(); this.state.animationFrameId = requestAnimationFrame(loop); };
            loop(); 
        },
        stopRenderLoop() { cancelAnimationFrame(this.state.animationFrameId); this.state.animationFrameId = null; this.drawFrame(); },

        drawControlsOverlay() {
            const isPasteboard = this.state.isCanvasViewZoomedOut;
            const ctx = isPasteboard ? this.dom.pasteboardCtx : this.dom.controlsCtx;
            const canvas = isPasteboard ? this.dom.pasteboardOverlayCanvas : this.dom.controlsOverlayCanvas;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        
            const activeLayer = this.getActiveLayer();
            const isEraserArmed = this.state.isEraserArmed;

            if (activeLayer && !isEraserArmed) {
                ctx.save();
                if (isPasteboard) ctx.translate(this.config.PASTEBOARD_MARGIN, this.config.PASTEBOARD_MARGIN);
                
                const { dWidth, dHeight } = this.getLayerMetrics(activeLayer);
                if (!dWidth || !dHeight) { ctx.restore(); return; }
                
                const scale = this.dom.movieCanvas.getBoundingClientRect().width / this.dom.movieCanvas.width;
                if (scale === 0 || !isFinite(scale)) { ctx.restore(); return; }

                const HANDLE_SCREEN_SIZE = 12, BORDER_SCREEN_WIDTH = 1.5, ROTATION_HANDLE_SCREEN_OFFSET = 26;
                const handleSize = HANDLE_SCREEN_SIZE / scale, lineWidth = BORDER_SCREEN_WIDTH / scale, rotationHandleOffset = ROTATION_HANDLE_SCREEN_OFFSET / scale;
                const ho = handleSize / 2;

                ctx.translate(activeLayer.x, activeLayer.y);
                ctx.rotate(activeLayer.rot * Math.PI / 180);

                let offsetX = 0, offsetY = 0;
                if ((activeLayer.type === 'image' || activeLayer.type === 'rasterized-image') && activeLayer.contentFrame) {
                    const fullWidth = activeLayer.size;
                    const fullHeight = activeLayer.size * (activeLayer.proxyCanvas.height / activeLayer.proxyCanvas.width);
                    const frameScale = fullWidth / activeLayer.proxyCanvas.width;
                    
                    const frameCenterX = (activeLayer.contentFrame.x + activeLayer.contentFrame.width / 2) * frameScale;
                    const frameCenterY = (activeLayer.contentFrame.y + activeLayer.contentFrame.height / 2) * frameScale;
                    
                    offsetX = frameCenterX - (fullWidth / 2);
                    offsetY = frameCenterY - (fullHeight / 2);
                    ctx.translate(offsetX, offsetY);
                }
                
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.strokeStyle = '#00FF00';
                ctx.fillStyle = '#00FF00';
                ctx.lineWidth = lineWidth;
                const halfW = dWidth / 2, halfH = dHeight / 2;
                ctx.strokeRect(-halfW, -halfH, dWidth, dHeight);
                ctx.beginPath(); ctx.arc(-halfW, -halfH, ho, 0, 2 * Math.PI); ctx.fill();
                ctx.beginPath(); ctx.arc(halfW, -halfH, ho, 0, 2 * Math.PI); ctx.fill();
                ctx.beginPath(); ctx.arc(-halfW, halfH, ho, 0, 2 * Math.PI); ctx.fill();
                ctx.beginPath(); ctx.arc(halfW, halfH, ho, 0, 2 * Math.PI); ctx.fill();
                
                const rotHandleY = -halfH - rotationHandleOffset;
                ctx.beginPath(); ctx.moveTo(0, -halfH); ctx.lineTo(0, rotHandleY); ctx.stroke();
                ctx.beginPath(); ctx.arc(0, rotHandleY, ho, 0, 2 * Math.PI); ctx.fill();
                
                ctx.restore();
            }

            if (this.state.eraserMode !== 'none') {
                const canvasPoint = this.getMovieCanvasPoint({clientX: this.state.eraseBrushPos.x + this.dom.movieCanvas.getBoundingClientRect().left, clientY: this.state.eraseBrushPos.y + this.dom.movieCanvas.getBoundingClientRect().top});
                ctx.save();
                if (isPasteboard) ctx.translate(this.config.PASTEBOARD_MARGIN, this.config.PASTEBOARD_MARGIN);
                const brushColor = this.state.eraserMode === 'unerase' ? 'rgba(85, 204, 85, 0.9)' : 'white';
                ctx.beginPath();
                ctx.arc(canvasPoint.x, canvasPoint.y, this.dom.eraserSize.value / 2, 0, 2 * Math.PI);
                ctx.strokeStyle = brushColor;
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(canvasPoint.x, canvasPoint.y, this.dom.eraserSize.value / 2, 0, 2 * Math.PI);
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();
            }
        },
        
        toggleCanvasZoom() {
            this.state.isCanvasViewZoomedOut = !this.state.isCanvasViewZoomedOut;
            this.dom.canvasPanel.classList.toggle('is-zoomed-out', this.state.isCanvasViewZoomedOut);
            this.updateCanvasPanelBackground();
            this.dom.toggleViewBtn.textContent = this.state.isCanvasViewZoomedOut ? '⛶' : '⬚';
            this.dom.toggleViewBtn.title = this.state.isCanvasViewZoomedOut ? 'Reset Canvas View (Z)' : 'Zoom Out Canvas (Z)';
            this.dom.movieCanvas.addEventListener('transitionend', () => this.drawFrame(), { once: true });
            requestAnimationFrame(() => { this.resizeCanvas(); });
        },

        downloadImage() {
            if (!this.state.canvasState.backgroundElement) { this.toast("Add a background before downloading.", 3000); return; }
            this.toast("Preparing high-quality image...", null);
            requestAnimationFrame(() => {
                try {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = this.dom.movieCanvas.width;
                    tempCanvas.height = this.dom.movieCanvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.imageSmoothingEnabled = true;
                    tempCtx.imageSmoothingQuality = 'high';
                    tempCtx.save();
                    tempCtx.filter = `brightness(${this.state.canvasState.bgBrightness}) saturate(${this.state.canvasState.bgSaturation})`;
                    tempCtx.drawImage(this.state.canvasState.backgroundElement, 0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.restore();
                    this.drawLayers(tempCtx, this.state.canvasState.layers, true);
                    const link = document.createElement('a');
                    link.download = 'image-maker-creation.png';
                    link.href = tempCanvas.toDataURL('image/png');
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    this.toast("Image download started!", 4000);
                } catch (error) {
                    console.error("Download failed:", error);
                    this.toast("Error: Could not generate image. Check console.", 5000);
                }
            }); 
        },

        getMovieCanvasPoint(e) {
            if (this.state.isCanvasViewZoomedOut) {
                const pbRect = this.dom.pasteboardOverlayCanvas.getBoundingClientRect();
                const scale = pbRect.width / this.dom.pasteboardOverlayCanvas.width;
                const xInPb = (e.clientX - pbRect.left) / scale;
                const yInPb = (e.clientY - pbRect.top) / scale;
                return { x: xInPb - this.config.PASTEBOARD_MARGIN, y: yInPb - this.config.PASTEBOARD_MARGIN };
            } else {
                const movieRect = this.dom.movieCanvas.getBoundingClientRect();
                const scaleX = this.dom.movieCanvas.width / movieRect.width;
                const scaleY = this.dom.movieCanvas.height / movieRect.height;
                return { x: (e.clientX - movieRect.left) * scaleX, y: (e.clientY - movieRect.top) * scaleY };
            }
        },
        
       // Replace your existing applyBrushToLayer function with this one
        applyBrushToLayer(layer, canvasPoint) {
            if (!layer || layer.type !== 'image' || !layer.proxyCtx) return;

            // We now draw onto a temporary clone of the canvas context
            const ctx = layer.proxyCtx; 
            const lastX = this.state.movieInteraction.lastProxyX;
            const lastY = this.state.movieInteraction.lastProxyY;

            // --- Calculation logic remains the same ---
            const dx = canvasPoint.x - layer.x, dy = canvasPoint.y - layer.y;
            const angle = -layer.rot * Math.PI / 180;
            const localX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const localY = dx * Math.sin(angle) + dy * Math.cos(angle);
            const assetWidth = layer.proxyCanvas.width, assetHeight = layer.proxyCanvas.height;
            const layerRenderWidth = layer.size, layerRenderHeight = layer.size * (assetHeight / assetWidth);
            const proxyX = (localX + layerRenderWidth / 2) * (assetWidth / layerRenderWidth);
            const proxyY = (localY + layerRenderHeight / 2) * (assetHeight / layerRenderHeight);
            const brushSize = this.dom.eraserSize.value * (assetWidth / layerRenderWidth);
            // --- End of calculation logic ---
            
            if (this.state.eraserMode === 'erase') {
                ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.lineWidth = brushSize;
                ctx.globalCompositeOperation = 'destination-out';
                ctx.strokeStyle = `rgba(0, 0, 0, ${parseFloat(this.dom.eraserStrength.value)})`;
                ctx.beginPath();
                if (lastX !== null && lastY !== null) { ctx.moveTo(lastX, lastY); } 
                else { ctx.moveTo(proxyX - 0.01, proxyY); }
                ctx.lineTo(proxyX, proxyY);
                ctx.stroke();
            } else { // Unerase logic
                const strength = parseFloat(this.dom.eraserStrength.value), radius = brushSize / 2;
                if (radius <= 0 || strength <= 0) return;
                const processUneraseDab = (x, y) => {
                    ctx.save();
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.globalAlpha = strength * 0.5;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.clip();
                    ctx.drawImage(layer.asset, 0, 0);
                    ctx.restore();
                };
                if (lastX !== null && lastY !== null) {
                    const dist = Math.hypot(proxyX - lastX, proxyY - lastY);
                    const angle = Math.atan2(proxyY - lastY, proxyX - lastX);
                    const step = Math.max(1, radius / 2);
                    for (let i = 0; i < dist; i += step) {
                        const x = lastX + Math.cos(angle) * i;
                        const y = lastY + Math.sin(angle) * i;
                        processUneraseDab(x, y);
                    }
                }
                processUneraseDab(proxyX, proxyY);
            }

            this.state.movieInteraction.lastProxyX = proxyX;
            this.state.movieInteraction.lastProxyY = proxyY;
            this.state.movieInteraction.didChangeContent = true; // Mark content as dirty
            this.drawFrame(); // Re-render to show the live erasing
            this.state.lastEraseCanvasPoint = canvasPoint;
        },

        getHandleWorldPosition(layer, handleName) {
            const { dWidth, dHeight } = this.getLayerMetrics(layer);
            if (!dWidth || !dHeight) return { x: layer.x, y: layer.y };
            let offsetX = 0, offsetY = 0;
            if ((layer.type === 'image' || layer.type === 'rasterized-image') && layer.contentFrame) {
                const fullWidth = layer.size;
                const fullHeight = layer.size * (layer.proxyCanvas.height / layer.proxyCanvas.width);
                const frameScale = fullWidth / layer.proxyCanvas.width;
                const frameCenterX = (layer.contentFrame.x + layer.contentFrame.width / 2) * frameScale;
                const frameCenterY = (layer.contentFrame.y + layer.contentFrame.height / 2) * frameScale;
                offsetX = frameCenterX - (fullWidth / 2);
                offsetY = frameCenterY - (fullHeight / 2);
            }
            const handles = {
                tl: { x: -dWidth / 2, y: -dHeight / 2 }, tr: { x: dWidth / 2, y: -dHeight / 2 },
                bl: { x: -dWidth / 2, y: dHeight / 2 }, br: { x: dWidth / 2, y: dHeight / 2 }
            };
            const h = handles[handleName];
            if (!h) return { x: layer.x, y: layer.y };
            const angle = layer.rot * Math.PI / 180, cos = Math.cos(angle), sin = Math.sin(angle);
            const handleWorldX = layer.x + ((offsetX + h.x) * cos - (offsetY + h.y) * sin);
            const handleWorldY = layer.y + ((offsetX + h.x) * sin + (offsetY + h.y) * cos);
            return { x: handleWorldX, y: handleWorldY };
        },

        getMovieHandleAtPoint(point, layer) {
            const scale = this.dom.movieCanvas.getBoundingClientRect().width / this.dom.movieCanvas.width;
            if (scale === 0 || !isFinite(scale)) return null;
            const DESIRED_HIT_RADIUS_ON_SCREEN = 16;
            const radius = DESIRED_HIT_RADIUS_ON_SCREEN / scale;
            const { dWidth, dHeight } = this.getLayerMetrics(layer);
            if (!dWidth || !dHeight) return null;
            let offsetX = 0, offsetY = 0;
            if ((layer.type === 'image' || layer.type === 'rasterized-image') && layer.contentFrame) {
                const fullWidth = layer.size;
                const fullHeight = layer.size * (layer.proxyCanvas.height / layer.proxyCanvas.width);
                const frameScale = fullWidth / layer.proxyCanvas.width;
                const frameCenterX = (layer.contentFrame.x + layer.contentFrame.width / 2) * frameScale;
                const frameCenterY = (layer.contentFrame.y + layer.contentFrame.height / 2) * frameScale;
                offsetX = frameCenterX - (fullWidth / 2);
                offsetY = frameCenterY - (fullHeight / 2);
            }
            const angle = layer.rot * Math.PI / 180, cos = Math.cos(angle), sin = Math.sin(angle);
            const ROTATION_HANDLE_SCREEN_OFFSET = 26;
            const rotationHandleOffset = ROTATION_HANDLE_SCREEN_OFFSET / scale;
            const rotHandleLocalX = 0;
            const rotHandleLocalY = -dHeight / 2 - rotationHandleOffset;
            const rotHandleWorldX = layer.x + ((offsetX + rotHandleLocalX) * cos - (offsetY + rotHandleLocalY) * sin);
            const rotHandleWorldY = layer.y + ((offsetX + rotHandleLocalX) * sin + (offsetY + rotHandleLocalY) * cos);
            if (Math.hypot(point.x - rotHandleWorldX, point.y - rotHandleWorldY) < radius) return 'rotate';
            const handles = { tl: { x: -dWidth / 2, y: -dHeight / 2 }, tr: { x: dWidth / 2, y: -dHeight / 2 }, bl: { x: -dWidth / 2, y: dHeight / 2 }, br: { x: dWidth / 2, y: dHeight / 2 } };
            for (const name in handles) {
                const h = handles[name];
                const handleWorldX = layer.x + ((offsetX + h.x) * cos - (offsetY + h.y) * sin);
                const handleWorldY = layer.y + ((offsetX + h.x) * sin + (offsetY + h.y) * cos);
                if (Math.hypot(point.x - handleWorldX, point.y - handleWorldY) < radius) return name;
            }
            return null;
        },

        isPixelOpaqueAtPoint(layer, point) {
            if (layer.type !== 'image' || !layer.proxyCanvas) { return true; }
            const dx = point.x - layer.x;
            const dy = point.y - layer.y;
            const angle = -layer.rot * Math.PI / 180;
            const localX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const localY = dx * Math.sin(angle) + dy * Math.cos(angle);
            const assetWidth = layer.proxyCanvas.width;
            const assetHeight = layer.proxyCanvas.height;
            const layerRenderWidth = layer.size;
            const layerRenderHeight = layer.size * (assetHeight / assetWidth);
            const scale = assetWidth / layerRenderWidth;
            const proxyX = Math.floor((localX + layerRenderWidth / 2) * scale);
            const proxyY = Math.floor((localY + layerRenderHeight / 2) * scale);
            if (proxyX < 0 || proxyX >= assetWidth || proxyY < 0 || proxyY >= assetHeight) { return false; }
            try {
                const pixelData = layer.proxyCtx.getImageData(proxyX, proxyY, 1, 1).data;
                return pixelData[3] > 10;
            } catch (e) {
                console.error("Could not read pixel data:", e);
                return false;
            }
        },
        
        handleMovieInteractionStart(e) {
            const point = this.getMovieCanvasPoint(e);
            const activeLayer = this.getActiveLayer();
            if (this.state.eraserMode !== 'none' && this.state.isEraserArmed) {
                e.preventDefault();
                if (activeLayer && this.isPointInMovieLayer(point, activeLayer)) {
                    this.state.movieInteraction = { active: true, type: 'erase', layerId: activeLayer.id, lastProxyX: null, lastProxyY: null };
                    this.state.lastEraseCanvasPoint = point;
                    this.applyBrushToLayer(activeLayer, point);
                }
                return;
            }
            e.preventDefault();
            let interactionFound = false;
            this.state.movieInteraction.didDrag = false;
            const handle = activeLayer ? this.getMovieHandleAtPoint(point, activeLayer) : null;
            if (activeLayer && handle) {
                interactionFound = true;
                const interactionData = { active: true, type: handle === 'rotate' ? 'rotate' : 'resize', layerId: activeLayer.id, handle: handle, startX: point.x, startY: point.y, initialState: JSON.parse(JSON.stringify(activeLayer)) };
                if (interactionData.type === 'resize') {
                    const oppositeHandles = { tl: 'br', tr: 'bl', bl: 'tr', br: 'tl' };
                    const oppositeHandleName = oppositeHandles[handle];
                    interactionData.anchorPoint = this.getHandleWorldPosition(activeLayer, oppositeHandleName);
                    interactionData.startHandlePoint = this.getHandleWorldPosition(activeLayer, handle);
                }
                this.state.movieInteraction = { ...this.state.movieInteraction, ...interactionData };
            } else {
                let layerToSelect = null;
                let topLayerHit = null;
                for (const layer of this.state.canvasState.layers) {
                    if (this.isPointInMovieLayer(point, layer)) {
                        topLayerHit = layer;
                        break;
                    }
                }
                if (topLayerHit && activeLayer && topLayerHit.id === activeLayer.id) {
                    layerToSelect = topLayerHit;
                } else if (topLayerHit) {
                    let foundOpaque = false;
                    for (const layer of this.state.canvasState.layers) {
                        if (this.isPointInMovieLayer(point, layer)) {
                            if (this.isPixelOpaqueAtPoint(layer, point)) {
                                layerToSelect = layer;
                                foundOpaque = true;
                                break;
                            }
                        }
                    }
                    if (!foundOpaque) {
                        layerToSelect = topLayerHit;
                    }
                }
                if (layerToSelect) {
                    interactionFound = true;
                    this.state.activeLayerId = layerToSelect.id;
                    this.state.movieInteraction = { active: true, type: 'drag', layerId: layerToSelect.id, offsetX: point.x - layerToSelect.x, offsetY: point.y - layerToSelect.y, startClickPoint: point };
                } else {
                    this.state.activeLayerId = null;
                }
            }
            this.updateLayerPaletteSelection();
            this.renderTextLayerPalette();
            this.updateEditPanelsUI();
            this.drawFrame();
            if (interactionFound) { this.startRenderLoop(); }
        },
        
        getLayerMetrics(layer) {
            if (!layer) return { dWidth: 0, dHeight: 0 };
            if (layer.type === 'image') {
                if (!layer.contentFrame || !layer.proxyCanvas) return { dWidth: 0, dHeight: 0 };
                const scale = layer.size / layer.proxyCanvas.width;
                return { dWidth: layer.contentFrame.width * scale, dHeight: layer.contentFrame.height * scale };
            } else if (layer.type === 'text') {
                const metrics = this.getTextBlockMetrics(this.dom.controlsCtx, layer.text, layer.font, layer.fontSize);
                layer.width = metrics.maxWidth; layer.height = metrics.totalHeight;
                return { dWidth: metrics.maxWidth, dHeight: metrics.totalHeight };
            }
            return { dWidth: 0, dHeight: 0 };
        },

        isPointInMovieLayer(point, layer) {
            if (!layer) return false;
            const { dWidth, dHeight } = this.getLayerMetrics(layer);
            if (dWidth === 0) return false;
            const dx = point.x - layer.x;
            const dy = point.y - layer.y;
            let offsetX = 0, offsetY = 0;
            if ((layer.type === 'image' || layer.type === 'rasterized-image') && layer.contentFrame) {
                const fullWidth = layer.size;
                const scale = fullWidth / layer.proxyCanvas.width;
                const frameCenterX = (layer.contentFrame.x + layer.contentFrame.width / 2) * scale;
                const frameCenterY = (layer.contentFrame.y + layer.contentFrame.height / 2) * scale;
                offsetX = frameCenterX - (fullWidth / 2);
                offsetY = frameCenterY - (layer.size * (layer.proxyCanvas.height / layer.proxyCanvas.width) / 2);
            }
            const angle = -layer.rot * Math.PI / 180;
            const localX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const localY = dx * Math.sin(angle) + dy * Math.cos(angle);
            return (Math.abs(localX - offsetX) < dWidth / 2 && Math.abs(localY - offsetY) < dHeight / 2);
        },

handleMovieInteractionMove(e) {
            const point = this.getMovieCanvasPoint(e);
            this.state.eraseBrushPos = { x: e.clientX - this.dom.movieCanvas.getBoundingClientRect().left, y: e.clientY - this.dom.movieCanvas.getBoundingClientRect().top };
            if (!this.state.movieInteraction.active) { this.updateCursor(e); if (this.state.eraserMode !== 'none') { this.drawControlsOverlay(); } return; }
            e.preventDefault();
            if (!this.state.movieInteraction.didDrag && this.state.movieInteraction.startClickPoint) {
                const dist = Math.hypot(point.x - this.state.movieInteraction.startClickPoint.x, point.y - this.state.movieInteraction.startClickPoint.y);
                if (dist > 3) { this.state.movieInteraction.didDrag = true; }
            }
            const l = this.getActiveLayer();
            if (!l) return;
            const iState = this.state.movieInteraction.initialState;
            if (this.state.movieInteraction.type === 'erase') { this.applyBrushToLayer(l, point); return; }
            let newTransform = {};
            if (this.state.movieInteraction.type === 'drag') {
                newTransform = { x: point.x - this.state.movieInteraction.offsetX, y: point.y - this.state.movieInteraction.offsetY };
            } else if (this.state.movieInteraction.type === 'rotate') {
                const initialAngle = Math.atan2(this.state.movieInteraction.startY - iState.y, this.state.movieInteraction.startX - iState.x) * 180 / Math.PI;
                const currentAngle = Math.atan2(point.y - iState.y, point.x - iState.x) * 180 / Math.PI;
                newTransform = { rot: iState.rot + (currentAngle - initialAngle) };
            } else if (this.state.movieInteraction.type === 'resize') {
                const { anchorPoint, startHandlePoint } = this.state.movieInteraction;
                const initialVector = { x: startHandlePoint.x - anchorPoint.x, y: startHandlePoint.y - anchorPoint.y };
                const currentMouseVector = { x: point.x - anchorPoint.x, y: point.y - anchorPoint.y };
                const initialDist = Math.hypot(initialVector.x, initialVector.y);
                if (initialDist > 1) {
                    const dotProduct = currentMouseVector.x * initialVector.x + currentMouseVector.y * initialVector.y;
                    const projectedDist = dotProduct / initialDist;
                    const scaleFactor = Math.max(0.01, projectedDist / initialDist);
                    const vectorFromAnchorToCenter = { x: iState.x - anchorPoint.x, y: iState.y - anchorPoint.y };
                    newTransform.x = anchorPoint.x + vectorFromAnchorToCenter.x * scaleFactor;
                    newTransform.y = anchorPoint.y + vectorFromAnchorToCenter.y * scaleFactor;
                    if (l.type === 'text') {
                        newTransform.fontSize = Math.max(10, iState.fontSize * scaleFactor);
                        this.dom.textSizeSlider.value = newTransform.fontSize;
                        this.updateSliderFill(this.dom.textSizeSlider);
                    } else {
                        newTransform.size = Math.max(20, iState.size * scaleFactor);
                    }
                }
            }
            this.dispatch({
                type: 'LAYER_TRANSFORMED',
                payload: {
                    layerId: l.id,
                    x: newTransform.x !== undefined ? newTransform.x : l.x,
                    y: newTransform.y !== undefined ? newTransform.y : l.y,
                    size: newTransform.size,
                    fontSize: newTransform.fontSize,
                    rot: newTransform.rot !== undefined ? newTransform.rot : l.rot
                }
            });
        },

        handleMovieInteractionEnd(e) {
            if (this.state.movieInteraction.active) {
                const wasErasing = this.state.movieInteraction.type === 'erase';
                const wasTransforming = ['drag', 'rotate', 'resize'].includes(this.state.movieInteraction.type);
                this.state.movieInteraction.active = false;
                this.stopRenderLoop();

                if (wasTransforming && !this.state.movieInteraction.didDrag) {
                    const clickPoint = this.state.movieInteraction.startClickPoint;
                    let finalLayerToSelect = null;
                    for (const layer of this.state.canvasState.layers) {
                        if (this.isPointInMovieLayer(clickPoint, layer) && this.isPixelOpaqueAtPoint(layer, clickPoint)) {
                            finalLayerToSelect = layer;
                            break;
                        }
                    }

                    if (finalLayerToSelect) {
                        this.state.activeLayerId = finalLayerToSelect.id;
                    } else {
                        const currentlyActiveLayer = this.getActiveLayer();
                        if (!currentlyActiveLayer || !this.isPointInMovieLayer(clickPoint, currentlyActiveLayer)) {
                            this.state.activeLayerId = null;
                        }
                    }

                    const currentPanelId = this.panelManager.activePanel;
                    const newActiveLayer = this.getActiveLayer();

                    if (newActiveLayer && currentPanelId !== 'default-panel') {
                        const newLayerType = newActiveLayer.type;
                        if (currentPanelId === 'visuals-panel' && newLayerType === 'text') {
                            this.panelManager.show('text-panel');
                        } else if (currentPanelId === 'text-panel' && newLayerType === 'image') {
                            this.panelManager.show('visuals-panel');
                            this.switchVisualsTab('asset');
                        }
                    }

                    this.updateLayerPaletteSelection();
                    this.renderTextLayerPalette();
                    this.updateEditPanelsUI();
                    this.drawFrame();
                }

                if (wasErasing && this.state.movieInteraction.didChangeContent) {
                    const layer = this.getActiveLayer();
                    if (layer) { layer.contentVersion = (layer.contentVersion || 0) + 1; }
                    this.renderLayerPalette();
                }

                this.state.movieInteraction.didChangeContent = false;
                if (wasErasing) { this.saveStateDebounced(); }
                else if (wasTransforming) { this.saveState(); }
            }
        },

      handleDoubleClick(e) {
    e.preventDefault();

    // If a panel is already open, the first double-click should just close it to return to the default view.
    if (this.panelManager.activePanel !== 'default-panel') {
        this.panelManager.show('default-panel');
        return;
    }

    const point = this.getMovieCanvasPoint(e);
    let topOpaqueLayer = null;
    let topBoundingBoxLayer = null;

    // This loop finds the topmost layer under the cursor, prioritizing one with a visible (opaque) pixel.
    for (const layer of this.state.canvasState.layers) {
        if (this.isPointInMovieLayer(point, layer)) {
            // We've found the first (topmost) layer whose bounding box is under the cursor.
            // This will be our fallback if no opaque pixel is found (e.g., for text layers).
            if (!topBoundingBoxLayer) {
                topBoundingBoxLayer = layer;
            }

            // Now, we check for an actual opaque pixel. This is the highest priority target.
            if (this.isPixelOpaqueAtPoint(layer, point)) {
                topOpaqueLayer = layer;
                break; // We found the correct layer, so we can stop searching.
            }
        }
    }

    // Decide which layer to act upon. The opaque layer wins.
    const targetLayer = topOpaqueLayer || topBoundingBoxLayer;

    if (targetLayer) {
        // A target layer was found. Select it and open the appropriate panel.
        this.state.activeLayerId = targetLayer.id;
        this.updateLayerPaletteSelection();
        this.renderTextLayerPalette();
        this.updateEditPanelsUI();
        this.drawFrame();

        if (targetLayer.type === 'image') {
            this.panelManager.show('visuals-panel');
            this.switchVisualsTab('asset');
        } else if (targetLayer.type === 'text') {
            this.loadSecondaryFonts(); // Ensure fonts are ready for the text panel
            this.panelManager.show('text-panel');
        }
        return; // Action complete.
    }

    // If no layer was targeted, it means the background was double-clicked.
    if (this.state.canvasState.backgroundElement) {
        this.state.activeLayerId = null; // Deselect any active layer
        this.updateLayerPaletteSelection();
        this.renderTextLayerPalette();
        this.updateEditPanelsUI();
        this.drawFrame();
        this.panelManager.show('visuals-panel');
        this.switchVisualsTab('background');
    }
},

        updateCursor(e) {
            if (this.state.eraserMode !== 'none') {
                this.dom.movieCanvas.style.cursor = 'none';
                this.dom.pasteboardOverlayCanvas.style.cursor = 'none';
                return;
            }
            this.dom.movieCanvas.style.cursor = '';
            this.dom.pasteboardOverlayCanvas.style.cursor = '';
            const point = this.getMovieCanvasPoint(e);
            let newCursor = 'default';
            const activeLayer = this.getActiveLayer();
            if (activeLayer) {
                const handle = this.getMovieHandleAtPoint(point, activeLayer);
                if (handle) {
                    newCursor = handle === 'rotate' ? 'grab' : (handle === 'tl' || handle === 'br' ? 'nwse-resize' : 'nesw-resize');
                } else if (this.isPointInMovieLayer(point, activeLayer)) {
                    newCursor = 'move';
                }
            } else {
                 for (let i = 0; i < this.state.canvasState.layers.length; i++) {
                    if (this.isPointInMovieLayer(point, this.state.canvasState.layers[i])) {
                        newCursor = 'pointer';
                        break;
                    }
                }
            }
            if (this.state.isCanvasViewZoomedOut) { this.dom.pasteboardOverlayCanvas.style.cursor = newCursor; }
            else { this.dom.movieCanvas.style.cursor = newCursor; }
        },

        handleKeyDown(e) {
            const key = e.key.toLowerCase();
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') { if (key === 'escape') document.activeElement.blur(); return; }
            if ((e.metaKey || e.ctrlKey) && key === 'z') { e.preventDefault(); this.undo(); return; }
            if ((e.metaKey || e.ctrlKey) && (key === 'y' || (e.shiftKey && key === 'z'))) { e.preventDefault(); this.redo(); return; }
            if ((e.metaKey || e.ctrlKey) && key === 's') { e.preventDefault(); if (!this.dom.saveProjectBtn.disabled) this.saveProjectToLibrary(); return; }
            if (key === 'z' && !(e.metaKey || e.ctrlKey)) { e.preventDefault(); this.toggleCanvasZoom(); return; }
            if (key === 'escape' && this.state.eraserMode !== 'none') { e.preventDefault(); this.deactivateEraser(); return; }
            const activeLayer = this.getActiveLayer();
            if (!activeLayer) return;
            
            if (key === 'q' || key === 'w') {
                e.preventDefault();
                const delta = key === 'q' ? -1 : 1;
                this.dispatch({ type: 'LAYER_REORDERED', payload: { layerId: activeLayer.id, delta: delta } });
                this.renderLayerPalette();
                this.renderTextLayerPalette();
                if(this.updateTextOrderButtonsState) this.updateTextOrderButtonsState();
                this.drawFrame();
                this.saveState();
                return;
            }

            let stateChanged = false;
            if (key === 'd' || key === 'f') {
                e.preventDefault();
                const scaleFactor = key === 'd' ? 1.05 : 0.95;
                if (activeLayer.type === 'image') {
                    activeLayer.size *= scaleFactor;
                    activeLayer.propSize = activeLayer.size / this.dom.movieCanvas.width;
                } else if (activeLayer.type === 'text') {
                    activeLayer.fontSize *= scaleFactor;
                    activeLayer.propSize = activeLayer.fontSize / this.dom.movieCanvas.height;
                    this.dom.textSizeSlider.value = activeLayer.fontSize;
                }
                 stateChanged = true;
            }
            else if (key === 's' && !(e.metaKey || e.ctrlKey)) { e.preventDefault(); activeLayer.flipX = !activeLayer.flipX; stateChanged = true; } 
            else if (key === 'delete' || key === 'backspace') { e.preventDefault(); this.deleteMovieLayer(activeLayer.id); this.toast('Layer deleted', 2000); return; }
            if (stateChanged) { this.drawFrame(); this.saveStateDebounced(); }
        },

        clearCanvas(isSoft = false) {
            this.state.canvasState.layers.forEach(layer => {
                if (layer.type === 'image' && layer.src.startsWith('blob:')) {
                    URL.revokeObjectURL(layer.src);
                    if (layer.originalTempSrc) URL.revokeObjectURL(layer.originalTempSrc);
                }
            });
            this.state.canvasState = { currentProjectId: null, backgroundElement: null, backgroundType: 'none', backgroundHash: null, bgBrightness: 1, bgSaturation: 1, layers: [], dominantColor: null };
            this.state.activeLayerId = null;
            this.deactivateEraser();
            this.updateCanvasPanelBackground();
            this.dom.movieCtx.clearRect(0, 0, this.dom.movieCanvas.width, this.dom.movieCanvas.height);
            this.dom.controlsCtx.clearRect(0, 0, this.dom.controlsOverlayCanvas.width, this.dom.controlsOverlayCanvas.height);
            this.dom.canvasPlaceholder.classList.remove('hidden');
            try { localStorage.removeItem('ims-autosave-project'); } catch (e) { console.warn("Could not clear autosave data from storage.", e); }
            this.updateControlsState();
            this.updateEditPanelsUI();
            this.drawFrame();
            if (!isSoft) {
                this.toast("Canvas cleared. Saved projects are safe.", 2000);
                this.state.history = []; this.state.historyIndex = -1; this.state.lastSavedStateHash = this.generateCanvasStateHash(); this.saveState();
            }
        },

        deactivateEraser() {
            if (this.state.eraserMode === 'none') return;
            this.state.eraserMode = 'none'; this.state.isEraserArmed = false;
            if (this.dom.eraserControlsWrapper) this.dom.eraserControlsWrapper.classList.add('disabled');
            if (this.dom.eraseBtn) this.dom.eraseBtn.classList.remove('active');
            if (this.dom.uneraseBtn) this.dom.uneraseBtn.classList.remove('active');
            if (this.dom.eraseToolBtn) this.dom.eraseToolBtn.classList.remove('active');
            if (this.dom.movieCanvas) this.dom.movieCanvas.classList.remove('erase-cursor');
            this.hideToast(); this.drawFrame();
            if (this.panelManager.activePanel === 'eraser-panel') { this.panelManager.show('default-panel'); }
        },

        setEraserMode(mode) {
            const activeLayer = this.getActiveLayer();
            if (!activeLayer || activeLayer.type !== 'image') {
                this.toast('Select an image layer to use the eraser.', 3000);
                this.panelManager.show('default-panel');
                return;
            }
            if (this.state.eraserMode === mode && this.state.isEraserArmed) {
                this.state.isEraserArmed = false;
            } else {
                this.state.eraserMode = mode;
                this.state.isEraserArmed = true;
            }
            this.dom.movieCanvas.classList.toggle('erase-cursor', this.state.isEraserArmed);
            this.dom.eraseBtn.classList.toggle('active', this.state.isEraserArmed && this.state.eraserMode === 'erase');
            this.dom.uneraseBtn.classList.toggle('active', this.state.isEraserArmed && this.state.eraserMode === 'unerase');
            this.dom.eraseToolBtn.classList.toggle('active', this.state.isEraserArmed);
            this.dom.eraserControlsWrapper.classList.remove('disabled');
            this.drawFrame();
            if (this.state.isEraserArmed) { this.toast(`${mode === 'erase' ? 'Erase' : 'Unerase'} Mode Armed.`, 2500); } 
            else { this.deactivateEraser(); }
        },

        openConfirmationModal(text, onConfirm) { this.dom.confirmationText.textContent = text; this.state.confirmCallback = onConfirm; this.dom.confirmationOverlay.classList.add('visible'); },
        closeConfirmationModal() { this.dom.confirmationOverlay.classList.remove('visible'); this.state.confirmCallback = null; },

        updateTextOrderButtonsState() {
            const textMoveBackBtn = document.getElementById('text-move-back');
            const textMoveForwardBtn = document.getElementById('text-move-forward');
            if (!textMoveBackBtn || !textMoveForwardBtn) return;
            const l = this.getActiveLayer();
            if (!l || l.type !== 'text') { textMoveBackBtn.disabled = true; textMoveForwardBtn.disabled = true; return; }
            const idx = this.state.canvasState.layers.findIndex(x => x.id === l.id);
            textMoveForwardBtn.disabled = (idx === 0);
            textMoveBackBtn.disabled = (idx === this.state.canvasState.layers.length - 1);
        },
        
        async getBgSession(mode) {
            if (this.state.bgSessionCache.has(mode)) return this.state.bgSessionCache.get(mode);
            const url = this.config.BG_MODELS[mode] || this.config.BG_MODELS.fast;
            const modelName = mode.charAt(0).toUpperCase() + mode.slice(1);
            this.toast(`Loading ${modelName} model`, null);
            try {
                const resp = await fetch(url, { mode: 'cors', cache: 'force-cache' });
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const bytes = await resp.arrayBuffer();
                const session = await ort.InferenceSession.create(bytes, { executionProviders: ['wasm'], graphOptimizationLevel: 'all' });
                this.state.bgSessionCache.set(mode, session);
                this.hideToast();
                return session;
            } catch (e) {
                this.hideToast();
                console.error(`Failed to load '${mode}' model from ${url}. Error: ${e.message}`);
                this.toast('Critical: Background removal model failed to load.', 5000);
                throw new Error("Could not load the background removal model.");
            }
        },

        rgbaToCHWFloat32(imgData, size = 320) {
            const { data } = imgData;
            const chw = new Float32Array(3 * size * size);
            let p = 0, rOff = 0, gOff = size * size, bOff = 2 * size * size;
            for (let i = 0; i < data.length; i += 4) {
                chw[rOff + p] = data[i] / 255;
                chw[gOff + p] = data[i + 1] / 255;
                chw[bOff + p] = data[i + 2] / 255;
                p++;
            }
            return chw;
        },

        // Add this new function inside the ImageMakerStudio object
        preprocess_bria: function(imgBitmap, modelInputSize) {
            const canvas = new OffscreenCanvas(modelInputSize[0], modelInputSize[1]);
            const ctx = canvas.getContext('2d');
            ctx.drawImage(imgBitmap, 0, 0, modelInputSize[0], modelInputSize[1]);
            const imageData = ctx.getImageData(0, 0, modelInputSize[0], modelInputSize[1]);
            const { data } = imageData;
            const float32Data = new Float32Array(3 * modelInputSize[0] * modelInputSize[1]);

            // CHW format and normalization
            for (let i = 0; i < data.length / 4; i++) {
                const R = data[i * 4 + 0];
                const G = data[i * 4 + 1];
                const B = data[i * 4 + 2];
                // Normalize: (pixel / 255.0 - 0.5) / 1.0
                float32Data[i] = R / 255.0 - 0.5;
                float32Data[i + modelInputSize[0] * modelInputSize[1]] = G / 255.0 - 0.5;
                float32Data[i + 2 * modelInputSize[0] * modelInputSize[1]] = B / 255.0 - 0.5;
            }
            return float32Data;
        },

      postprocess_bria: function(resultTensor, originalSize) {
            const outputData = resultTensor.data;
            const maskCanvas = new OffscreenCanvas(resultTensor.dims[3], resultTensor.dims[2]);
            const maskCtx = maskCanvas.getContext('2d');
            const maskImageData = maskCtx.createImageData(resultTensor.dims[3], resultTensor.dims[2]);

            // Step 1: Normalize the raw output from the model to a 0-1 range
            let minValue = Infinity;
            let maxValue = -Infinity;
            for (let i = 0; i < outputData.length; i++) {
                if (outputData[i] < minValue) minValue = outputData[i];
                if (outputData[i] > maxValue) maxValue = outputData[i];
            }
            const range = maxValue - minValue;

            // --- THE CRUCIAL FIX IS HERE ---
            // Step 2: Clean the mask by applying a contrast-enhancing curve (sigmoid-like).
            // This will crush faint artifacts to pure black (transparent) and boost
            // the subject to pure white (opaque), creating a much cleaner edge.
            for (let i = 0; i < outputData.length; i++) {
                // Normalize the value from 0 to 1
                const normalizedValue = (outputData[i] - minValue) / range;
                
                // Apply a smoothstep function to sharpen the mask.
                // Values below 0.4 become much darker, values above 0.6 become much lighter.
                let sharpenedValue = normalizedValue * normalizedValue * (3.0 - 2.0 * normalizedValue);
                
                const pixelValue = Math.round(sharpenedValue * 255);
                
                maskImageData.data[i * 4 + 0] = 0; // R
                maskImageData.data[i * 4 + 1] = 0; // G
                maskImageData.data[i * 4 + 2] = 0; // B
                maskImageData.data[i * 4 + 3] = pixelValue; // Alpha
            }
            maskCtx.putImageData(maskImageData, 0, 0);
            // --- END OF FIX ---

            // Step 3: Resize the cleaned mask back to the original image size
            const finalMask = new OffscreenCanvas(originalSize.width, originalSize.height);
            const finalCtx = finalMask.getContext('2d');
            finalCtx.imageSmoothingEnabled = true;
            finalCtx.imageSmoothingQuality = 'high';
            finalCtx.drawImage(maskCanvas, 0, 0, originalSize.width, originalSize.height);
            return finalMask;
        },

        letterboxToSquareBitmap(imgBitmap, size = 320) {
            const canvas = new OffscreenCanvas(size, size);
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            const scale = Math.min(size / imgBitmap.width, size / imgBitmap.height);
            const dw = Math.round(imgBitmap.width * scale), dh = Math.round(imgBitmap.height * scale);
            const dx = Math.floor((size - dw) / 2), dy = Math.floor((size - dh) / 2);
            ctx.clearRect(0, 0, size, size);
            ctx.drawImage(imgBitmap, 0, 0, imgBitmap.width, imgBitmap.height, dx, dy, dw, dh);
            return { canvas, dx, dy, dw, dh };
        },
        
   async runU2NetOnImageLayer(layer, session) {
            const bmp = await createImageBitmap(layer.asset);
            const modelInputSize = [1024, 1024];
            
            this.toast('Processing image...', null);
            await new Promise(resolve => setTimeout(resolve, 50));
            
            const preprocessedData = this.preprocess_bria(bmp, modelInputSize);
            const inputTensor = new ort.Tensor('float32', preprocessedData, [1, 3, modelInputSize[0], modelInputSize[1]]);
            
            const feeds = { [session.inputNames[0]]: inputTensor };
            const results = await session.run(feeds);
            const resultTensor = results[session.outputNames[0]];
            
            const originalSize = { width: bmp.width, height: bmp.height };
            const finalMask = this.postprocess_bria(resultTensor, originalSize);
            
            const proxy = layer.proxyCanvas;
            const ctx = layer.proxyCtx;
            ctx.clearRect(0, 0, proxy.width, proxy.height);
            ctx.drawImage(layer.asset, 0, 0);
            ctx.save();
            ctx.globalCompositeOperation = 'destination-in';
            ctx.drawImage(finalMask, 0, 0, proxy.width, proxy.height);
            ctx.restore();

            // --- ALL-NEW REPLACEMENT LOGIC ---

            // 1. Calculate the new, tight bounds of the visible content.
            const newBounds = this.calculateContentBounds(layer.proxyCanvas);

            // 2. If the layer is empty or already perfectly cropped, we are done.
            if (newBounds.isEmpty || (newBounds.width === layer.proxyCanvas.width && newBounds.height === layer.proxyCanvas.height)) {
                layer.contentVersion = (layer.contentVersion || 0) + 1; // Still update version for thumbnail refresh
                return;
            }

            // 3. Create a new, tightly cropped canvas.
            const newCanvas = document.createElement('canvas');
            newCanvas.width = newBounds.width;
            newCanvas.height = newBounds.height;
            const newCtx = newCanvas.getContext('2d', { willReadFrequently: true });
            newCtx.drawImage(
                layer.proxyCanvas,
                newBounds.x, newBounds.y, newBounds.width, newBounds.height,
                0, 0, newBounds.width, newBounds.height
            );

            // 4. Calculate how the layer's position and size must change to keep the content stationary.
            const oldCenter = { x: layer.proxyCanvas.width / 2, y: layer.proxyCanvas.height / 2 };
            const newContentCenter = { x: newBounds.x + newBounds.width / 2, y: newBounds.y + newBounds.height / 2 };
            const shiftInLocalSpace = { x: newContentCenter.x - oldCenter.x, y: newContentCenter.y - oldCenter.y };
            
            const scale = layer.size / layer.proxyCanvas.width;
            const angle = layer.rot * Math.PI / 180;
            const rotatedShift = {
                x: shiftInLocalSpace.x * Math.cos(angle) - shiftInLocalSpace.y * Math.sin(angle),
                y: shiftInLocalSpace.x * Math.sin(angle) + shiftInLocalSpace.y * Math.cos(angle)
            };

            // 5. Build the transformation payload.
            const transformPayload = {
                x: layer.x + rotatedShift.x * scale,
                y: layer.y + rotatedShift.y * scale,
                size: layer.size * (newBounds.width / layer.proxyCanvas.width),
                proxyCanvas: newCanvas,
                proxyCtx: newCtx,
                contentFrame: { x: 0, y: 0, width: newBounds.width, height: newBounds.height, isEmpty: false }
            };

            // Also update the proportional values used for canvas resizing.
            transformPayload.propX = transformPayload.x / this.dom.movieCanvas.width;
            transformPayload.propY = transformPayload.y / this.dom.movieCanvas.height;
            transformPayload.propSize = transformPayload.size / this.dom.movieCanvas.width;

            // 6. Dispatch the action to the reducer, which will safely update the state.
            this.dispatch({
                type: 'LAYER_REFIT_AND_TRANSFORM',
                payload: { layerId: layer.id, transform: transformPayload }
            });
      },
        async removeBgForActiveImageLayer() {
            this.panelManager.show('default-panel');
            const active = this.getActiveLayer();
            if (!active || active.type !== 'image') { this.toast('Select an image layer first.', 2500); return; }
            const mode = 'fast';
            try {
                const session = await this.getBgSession(mode);
                if (!session) return; 
                this.toast(`Removing background`, null);
                await new Promise(resolve => setTimeout(resolve, 50));
                await this.runU2NetOnImageLayer(active, session);
                this.toast(`Background removed.`, 2500);
                if(this.renderLayerPalette) this.renderLayerPalette();
                if(this.drawFrame) this.drawFrame();
                this.saveState();
            } catch (err) {
                console.error(err);
                this.hideToast();
                this.toast('BG removal failed. See console.', 4000);
            }
        },
        
        upscaleMaskToLayer(maskBitmap, boxed, layerWidth, layerHeight) {
            const { dx, dy, dw, dh } = boxed;
            const tempMaskCanvas = new OffscreenCanvas(maskBitmap.width, maskBitmap.height);
            tempMaskCanvas.getContext('2d').drawImage(maskBitmap, 0, 0);
            const croppedMaskCanvas = new OffscreenCanvas(dw, dh);
            croppedMaskCanvas.getContext('2d').drawImage(tempMaskCanvas, dx, dy, dw, dh, 0, 0, dw, dh);
            const finalMaskCanvas = new OffscreenCanvas(layerWidth, layerHeight);
            const finalCtx = finalMaskCanvas.getContext('2d');
            finalCtx.imageSmoothingEnabled = true;
            finalCtx.imageSmoothingQuality = 'high';
            finalCtx.drawImage(croppedMaskCanvas, 0, 0, dw, dh, 0, 0, layerWidth, layerHeight);
            return finalMaskCanvas;
        },

        featherMask(canvas, amount = 1.2) {
            const ctx = canvas.getContext('2d');
            if (amount > 0) {
                ctx.filter = `blur(${amount}px)`;
                ctx.drawImage(canvas, 0, 0);
                ctx.filter = 'none';
            }
        },
        
        async getSavableState(includeAssetData = false) {
            const savableState = {
                // THE FIX: Ensure these are always included from the start
                currentProjectId: this.state.canvasState.currentProjectId,
                backgroundHash: this.state.canvasState.backgroundHash,
                bgBrightness: this.state.canvasState.bgBrightness,
                bgSaturation: this.state.canvasState.bgSaturation,
                layers: []
            };

            if (includeAssetData && this.state.canvasState.backgroundHash) {
                savableState.assetData = {};
                const backgroundAsset = await this.idbFindByHash(this.state.canvasState.backgroundHash);
                if (backgroundAsset.length > 0) {
                    savableState.assetData[this.state.canvasState.backgroundHash] = await this.toDataURL(backgroundAsset[0].full);
                }
            }
            
            for (const layer of this.state.canvasState.layers) {
                const { asset, proxyCanvas, proxyCtx, ...serializableLayer } = layer;
                if (layer.type === 'image') {
                    serializableLayer.proxyCanvasDataURL = proxyCanvas.toDataURL('image/webp', 0.9);
                    if (includeAssetData && layer.originalHash && savableState.assetData) {
                        if (!savableState.assetData[layer.originalHash]) {
                            const layerAsset = await this.idbFindByHash(layer.originalHash);
                            if (layerAsset.length > 0) {
                                savableState.assetData[layer.originalHash] = await this.toDataURL(layerAsset[0].full);
                            }
                        }
                    }
                }
                savableState.layers.push(serializableLayer);
            }
            return savableState;
        },

        async saveCurrentWork() {
            if (!this.state.canvasState.backgroundElement) return;
            try {
                const state = await this.getSavableState();
                localStorage.setItem('ims-autosave-project', JSON.stringify(state));
            } catch (e) {
                console.warn("Autosave failed. Storage may be inaccessible.", e);
            }
        },

        async saveProjectToLibrary() {
            if (!this.state.canvasState.backgroundElement) { this.toast("A background is required to save a project.", 3000); return; }
            this.toast("Saving project to library...", null);
            const thumbCanvas = document.createElement('canvas');
            const THUMB_MAX_SIZE = 256;
            const aspect = this.dom.movieCanvas.width / this.dom.movieCanvas.height;
            thumbCanvas.width = aspect >= 1 ? THUMB_MAX_SIZE : THUMB_MAX_SIZE * aspect;
            thumbCanvas.height = aspect < 1 ? THUMB_MAX_SIZE : THUMB_MAX_SIZE / aspect;
            const thumbCtx = thumbCanvas.getContext('2d');
            thumbCtx.imageSmoothingQuality = 'high';
            thumbCtx.filter = `brightness(${this.state.canvasState.bgBrightness}) saturate(${this.state.canvasState.bgSaturation})`;
            thumbCtx.drawImage(this.state.canvasState.backgroundElement, 0, 0, thumbCanvas.width, thumbCanvas.height);
            thumbCtx.filter = 'none';
            thumbCtx.save();
            thumbCtx.scale(thumbCanvas.width / this.dom.movieCanvas.width, thumbCanvas.height / this.dom.movieCanvas.height);
            this.drawLayers(thumbCtx, this.state.canvasState.layers, true);
            thumbCtx.restore();
            const thumbnailBlob = await new Promise(resolve => thumbCanvas.toBlob(resolve, 'image/webp', 0.8));
            const projectState = await this.getSavableState();
            const record = { createdAt: Date.now(), thumbnail: thumbnailBlob, projectState };
            let toastMessage = "Project saved to library!";
            if (this.state.canvasState.currentProjectId) { record.id = this.state.canvasState.currentProjectId; toastMessage = "Project updated in library!"; }
            const savedRecord = await this.idbPut(record, 'projects');
            this.state.canvasState.currentProjectId = savedRecord.id;
            await this.saveCurrentWork();
            this.state.lastSavedStateHash = this.generateCanvasStateHash();
            this.toast(toastMessage, 2500);
        },

        async createLayerFromSave(savedLayer) {
            if (savedLayer.type === 'text') {
                return { ...savedLayer, createdAt: Date.now() };
            }
            if (savedLayer.type === 'image') {
                try {
                    const assetRecords = await this.idbFindByHash(savedLayer.originalHash);
                    if (!assetRecords || assetRecords.length === 0) { throw new Error(`Asset with hash ${savedLayer.originalHash} not in library.`); }
                    const assetBlob = assetRecords[0].full;
                    const asset = new Image();
                    asset.src = URL.createObjectURL(assetBlob);
                    const proxyImage = new Image();
                    proxyImage.src = savedLayer.proxyCanvasDataURL;
                    await Promise.all([asset.decode(), proxyImage.decode()]);
                    const proxyCanvas = document.createElement('canvas');
                    proxyCanvas.width = proxyImage.naturalWidth;
                    proxyCanvas.height = proxyImage.naturalHeight;
                    const proxyCtx = proxyCanvas.getContext('2d', { willReadFrequently: true });
                    proxyCtx.drawImage(proxyImage, 0, 0);
                    const restoredLayer = { ...savedLayer, asset, proxyCanvas, proxyCtx, createdAt: Date.now(), isOptimized: true, src: asset.src };
                    if (!restoredLayer.contentFrame) {
                        restoredLayer.contentFrame = this.calculateContentBounds(proxyCanvas);
                    }
                    delete restoredLayer.proxyCanvasDataURL;
                    return restoredLayer;
                } catch (error) {
                    console.error("Error restoring image layer:", error);
                    this.toast(`Skipping a layer: ${error.message}`, 3500);
                    return null;
                }
            }
            return null;
        },

        async restoreProjectState(projectState) {
            const textLayers = projectState.layers.filter(l => l.type === 'text' && l.font);
            const uniqueFontValues = [...new Set(textLayers.map(l => l.font))];
            const fontNamesToLoad = uniqueFontValues.map(value => this.config.fontValueToNameMap.get(value)).filter(name => name && name !== 'VT323');
            await this.loadSpecificFonts(fontNamesToLoad);

            if (!projectState.backgroundHash) { throw new Error("Saved project is missing a background."); }

            let bgAssets = await this.idbFindByHash(projectState.backgroundHash);
            
            // THE UPGRADE: If the background isn't in our local library, check the bundle.
            if (bgAssets.length === 0 && projectState.assetData && projectState.assetData[projectState.backgroundHash]) {
                console.log(`Background asset ${projectState.backgroundHash} not found locally. Using bundled data.`);
                const blob = await this.toBlobFromDataURL(projectState.assetData[projectState.backgroundHash]);
                // Save it to our own library for future use
                await this.saveAssetToLibrary({ blob, mime: blob.type, hash: projectState.backgroundHash, kind: 'background' });
                bgAssets = await this.idbFindByHash(projectState.backgroundHash);
            }

            if (!bgAssets || bgAssets.length === 0) { throw new Error("Background asset for saved project not found in library or bundle."); }
            
            const img = new Image();
            img.src = URL.createObjectURL(bgAssets[0].full);
            await img.decode();

            this.clearCanvas(true);
            this.setBackground(img, projectState.backgroundHash, true);
            this.state.canvasState.bgBrightness = projectState.bgBrightness || 1;
            this.state.canvasState.bgSaturation = projectState.bgSaturation || 1;
            this.state.canvasState.currentProjectId = projectState.currentProjectId || null;
            this.state.canvasState.dominantColor = this.getDominantColor(img);
            this.updateCanvasPanelBackground();
            
            const createLayerFromSaveWithBundle = async (savedLayer) => {
                if (savedLayer.type === 'text') {
                    return { ...savedLayer, createdAt: Date.now() };
                }
                if (savedLayer.type === 'image') {
                    try {
                        let assetRecords = await this.idbFindByHash(savedLayer.originalHash);
                        // THE UPGRADE: If the layer asset isn't in our library, check the bundle.
                        if (assetRecords.length === 0 && projectState.assetData && projectState.assetData[savedLayer.originalHash]) {
                             console.log(`Layer asset ${savedLayer.originalHash} not found locally. Using bundled data.`);
                             const blob = await this.toBlobFromDataURL(projectState.assetData[savedLayer.originalHash]);
                             await this.saveAssetToLibrary({ blob, mime: blob.type, hash: savedLayer.originalHash, kind: 'asset' });
                             assetRecords = await this.idbFindByHash(savedLayer.originalHash);
                        }

                        if (!assetRecords || assetRecords.length === 0) { throw new Error(`Asset with hash ${savedLayer.originalHash} not in library or bundle.`); }
                        
                        const assetBlob = assetRecords[0].full;
                        const asset = new Image();
                        asset.src = URL.createObjectURL(assetBlob);
                        const proxyImage = new Image();
                        proxyImage.src = savedLayer.proxyCanvasDataURL;
                        await Promise.all([asset.decode(), proxyImage.decode()]);

                        const proxyCanvas = document.createElement('canvas');
                        proxyCanvas.width = proxyImage.naturalWidth;
                        proxyCanvas.height = proxyImage.naturalHeight;
                        const proxyCtx = proxyCanvas.getContext('2d', { willReadFrequently: true });
                        proxyCtx.drawImage(proxyImage, 0, 0);

                        const restoredLayer = { ...savedLayer, asset, proxyCanvas, proxyCtx, createdAt: Date.now(), isOptimized: true, src: asset.src };
                        if (!restoredLayer.contentFrame) {
                            restoredLayer.contentFrame = this.calculateContentBounds(proxyCanvas);
                        }
                        delete restoredLayer.proxyCanvasDataURL;
                        return restoredLayer;
                    } catch (error) {
                        console.error("Error restoring image layer:", error);
                        this.toast(`Skipping a layer: ${error.message}`, 3500);
                        return null;
                    }
                }
                return null;
            };

            const layerPromises = projectState.layers.map(l => createLayerFromSaveWithBundle(l));
            const loadedLayers = await Promise.all(layerPromises);

            this.state.canvasState.layers = loadedLayers.filter(l => l !== null);
            this.updateControlsState();
            this.updateEditPanelsUI();
            this.renderLayerPalette();
            this.renderTextLayerPalette();
            this.drawFrame();
            await this.saveCurrentWork();
            this.state.history = [];
            this.state.historyIndex = -1;
            this.saveState();
        },

         // Helper to convert blob to dataURL
        toDataURL(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        },
        
        async restoreCurrentWork() {
            const savedData = localStorage.getItem('ims-autosave-project');
            if (!savedData) { this.saveState(); return; } 
            try {
                const projectState = JSON.parse(savedData);
                this.toast("Restoring previous work...", null);
                await this.restoreProjectState(projectState);
                this.toast("Work restored!", 2000);
            } catch (error) {
                console.error("Failed to restore project:", error);
                this.toast(`Could not restore work: ${error.message}`, 4000);
                localStorage.removeItem('ims-autosave-project');
                this.saveState();
            }
        },

        debounce(func, delay) {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        },

        saveStateDebounced: null, 

       saveState() {
            if (this.state.historyIndex < this.state.history.length - 1) {
                this.state.history = this.state.history.slice(0, this.state.historyIndex + 1);
            }

            // THE FIX: We use the slow, safe copy method HERE for the history snapshot.
            const snapshot = JSON.parse(JSON.stringify(this.state.canvasState));
            // We don't need the live background element in the history.
            snapshot.backgroundElement = null;

            this.state.history.push(snapshot);
            if (this.state.history.length > this.config.HISTORY_LIMIT) {
                this.state.history.shift();
            }
            this.state.historyIndex = this.state.history.length - 1;
        },

        async applyState(stateToApply) {
            for (const layer of stateToApply.layers) {
                if (layer.type === 'image' && layer.proxyCanvasDataURL) {
                    const img = new Image();
                    img.src = layer.proxyCanvasDataURL;
                    await img.decode();
                    const proxyCanvas = document.createElement('canvas');
                    proxyCanvas.width = img.width;
                    proxyCanvas.height = img.height;
                    const proxyCtx = proxyCanvas.getContext('2d');
                    proxyCtx.drawImage(img, 0, 0);
                    layer.proxyCanvas = proxyCanvas;
                    layer.proxyCtx = proxyCtx;
                }
            }
            stateToApply.backgroundElement = this.state.canvasState.backgroundElement;
            this.state.canvasState = stateToApply;
            this.updateEditPanelsUI();
            this.renderLayerPalette();
            this.renderTextLayerPalette();
            this.drawFrame();
        },

        undo() {
            if (this.state.historyIndex > 0) {
                this.state.historyIndex--;
                const stateToRestore = JSON.parse(JSON.stringify(this.state.history[this.state.historyIndex]));
                this.applyState(stateToRestore);
                this.toast('Undo', 1500);
            } else {
                this.toast("Nothing more to undo", 2000);
            }
        },

        redo() {
            if (this.state.historyIndex < this.state.history.length - 1) {
                this.state.historyIndex++;
                const stateToRestore = JSON.parse(JSON.stringify(this.state.history[this.state.historyIndex]));
                this.applyState(stateToRestore);
                this.toast('Redo', 1500);
            } else {
                this.toast("Nothing more to redo", 2000);
            }
        },
        
        addBgUI() {
            const panel = document.getElementById('ai-tools-panel');
            if (!panel || panel.querySelector('.mg-btn')) return;
            const btn = document.createElement('button');
            btn.className = 'mg-btn';
            btn.textContent = 'Remove Background';
            btn.style.marginTop = '0.5rem';
            btn.addEventListener('click', () => this.removeBgForActiveImageLayer());
            panel.appendChild(btn);
        },

        openFontPreviewModal() {
            const activeLayer = this.getActiveLayer();
            if (!activeLayer || activeLayer.type !== 'text') {
                this.toast('Select a text layer first.', 3000);
                return;
            }
            this.loadSecondaryFonts().then(() => {
                this.populateFontPreviewGrid();
                this.dom.fontPreviewOverlay.classList.add('visible');
            }).catch(err => {
                console.error("Could not load fonts for preview:", err);
                this.toast("Error: Could not load fonts for preview.", 4000);
            });
        },

        closeFontPreviewModal() {
            this.dom.fontPreviewOverlay.classList.remove('visible');
        },

        populateFontPreviewGrid() {
            const activeLayer = this.getActiveLayer();
            if (!activeLayer) return;
            this.dom.fontPreviewGrid.innerHTML = '';
            const previewText = activeLayer.text.trim() || 'Sample Text';
            const fragment = document.createDocumentFragment();
            this.config.availableFonts.forEach(font => {
                const item = document.createElement('div');
                item.className = 'font-preview-item';
                item.textContent = previewText;
                item.style.fontFamily = font.value;
                if (font.style) {
                     item.setAttribute('style', `font-family: ${font.value}; ${font.style}`);
                }
                item.dataset.fontValue = font.value;
                item.dataset.fontName = font.name;
                item.title = font.name;
                item.addEventListener('click', () => {
                    activeLayer.font = font.value;
                    this.dom.fontSelectTrigger.querySelector('span').textContent = font.name;
                    this.dom.fontSelectTrigger.querySelector('span').style.fontFamily = font.value;
                    if (this.dom.fontSelectList.querySelector('.selected')) {
                        this.dom.fontSelectList.querySelector('.selected').classList.remove('selected');
                    }
                    const liToSelect = this.dom.fontSelectList.querySelector(`[data-font-value="${font.value}"]`);
                    if (liToSelect) liToSelect.classList.add('selected');
                    this.drawFrame();
                    this.saveState();
                    this.closeFontPreviewModal();
                });
                fragment.appendChild(item);
            });
            this.dom.fontPreviewGrid.appendChild(fragment);
        },

        setupEventListeners() {
            const versionLink = document.getElementById('version-link'), versionPopupOverlay = document.getElementById('version-popup-overlay'), closeButton = document.getElementById('close-popup');
            versionLink.addEventListener('click', (e) => { e.preventDefault(); versionPopupOverlay.style.display = 'flex'; });
            closeButton.addEventListener('click', () => { versionPopupOverlay.style.display = 'none'; });
            versionPopupOverlay.addEventListener('click', (e) => { if (e.target === versionPopupOverlay) versionPopupOverlay.style.display = 'none'; });
            this.dom.themeSelectLink.addEventListener('click', (e) => { e.preventDefault(); this.state.themeChosen = false; this.dom.themePopupOverlay.style.display = 'flex'; });
            this.dom.themePopupContent.addEventListener('mouseleave', () => { if (!this.state.themeChosen) this.applyTheme(this.state.originalTheme, true); });
            this.dom.themePopupOverlay.addEventListener('click', (e) => { if (e.target === this.dom.themePopupOverlay) { if (!this.state.themeChosen) this.applyTheme(this.state.originalTheme); this.dom.themePopupOverlay.style.display = 'none'; } });
            this.dom.canvasPlaceholder.addEventListener('click', () => this.dom.initialBackgroundInput.click());
            this.dom.initialBackgroundInput.addEventListener('change', e => { this.handleFileUpload(e.target.files[0], 'background'); e.target.value = null; });
            this.dom.downloadImageBtn.addEventListener('click', () => this.downloadImage());
            this.dom.saveProjectBtn.addEventListener('click', () => this.saveProjectToLibrary());
            this.dom.clearCanvasBtn.addEventListener('click', () => this.openConfirmationModal("This will clear the canvas and start a new project. Are you sure?", () => { this.clearCanvas(); this.closeConfirmationModal(); }));
            const addLayerCloseBtn = document.getElementById('mg-asset-library-close'), dropZone = document.getElementById('mg-asset-drop-zone');
            addLayerCloseBtn.addEventListener('click', () => this.closeAddLayerPopup());
            this.dom.addLayerOverlay.addEventListener('click', e => { if (e.target === this.dom.addLayerOverlay) this.closeAddLayerPopup() });
            dropZone.addEventListener('click', () => this.dom.addLayerFileInput.click());
            this.dom.addLayerFileInput.addEventListener('change', e => { this.handleFileUpload(e.target.files?.[0], this.state.addAssetMode); e.target.value = null; this.closeAddLayerPopup(); });
            dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('drag-over'); });
            dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
            dropZone.addEventListener('drop', e => { e.preventDefault(); dropZone.classList.remove('drag-over'); const file = e.dataTransfer.files[0]; if (file) { this.handleFileUpload(file, this.state.addAssetMode); this.closeAddLayerPopup(); } });
            this.dom.visualsBtn.addEventListener('click', () => {
                const targetPanel = 'visuals-panel';
                if (this.panelManager.activePanel === targetPanel) {
                    this.panelManager.show('default-panel');
                } else {
                    this.panelManager.show(targetPanel);
                    if (this.getActiveLayer() && this.getActiveLayer().type === 'image') { this.switchVisualsTab('asset'); } 
                    else { this.switchVisualsTab('background'); }
                }
            });
            this.dom.textBtn.addEventListener('click', () => {
                const targetPanel = 'text-panel';
                if (this.panelManager.activePanel === targetPanel) {
                    this.panelManager.show('default-panel');
                } else {
                    this.loadSecondaryFonts(); 
                    this.panelManager.show(targetPanel);
                }
            });
            this.dom.eraseToolBtn.addEventListener('click', () => {
                const targetPanel = 'eraser-panel';
                if (this.panelManager.activePanel === targetPanel) {
                    this.panelManager.show('default-panel');
                } else {
                    this.panelManager.show(targetPanel);
                }
            });
            this.dom.aiToolsBtn.addEventListener('click', async () => {
                const targetPanel = 'ai-tools-panel';
                if (this.panelManager.activePanel === targetPanel) {
                    this.panelManager.show('default-panel');
                } else {
                    if (!this.state.onnxLoaded) {
                        this.toast('Loading AI engine...', null);
                        try {
                            await this.loadOnnxRuntime();
                            ort.env.wasm.simd = true; ort.env.wasm.numThreads = 1;
                            this.state.onnxLoaded = true; this.hideToast();
                        } catch (error) { console.error("Failed to load ONNX Runtime:", error); this.toast('Error: Could not load the AI engine.', 4000); return; }
                    }
                    this.panelManager.show(targetPanel);
                }
            });
            document.querySelectorAll('.back-button').forEach(button => {
                button.addEventListener('click', () => {
                    this.panelManager.show(button.dataset.target);
                });
            });
            this.dom.shortcutsBtn.addEventListener('click', e => {
                e.stopPropagation();
                this.panelManager.show('default-panel');
                this.dom.shortcutsDropdown.classList.toggle('visible');
            });
            this.dom.addNewTextLayerBtn.addEventListener('click', () => this.addTextLayer());
            this.dom.confirmYesBtn.addEventListener('click', async (e) => { e.stopPropagation(); const fn = this.state.confirmCallback; this.state.confirmCallback = null; try { if (typeof fn === 'function') await fn(); } catch (err) { console.error('Confirmation action failed:', err); this.toast('Error: Could not complete the action.', 4000); } finally { this.closeConfirmationModal(); } });
            this.dom.confirmNoBtn.addEventListener('click', (e) => { e.stopPropagation(); this.closeConfirmationModal(); });
            this.dom.confirmationOverlay.addEventListener('click', (e) => { if (e.target === this.dom.confirmationOverlay) this.closeConfirmationModal(); });
            this.dom.canvasPanel.addEventListener('mousedown', (e) => this.handleMovieInteractionStart(e));
           this.dom.canvasPanel.addEventListener('dblclick', (e) => this.handleDoubleClick(e));
            window.addEventListener('mousemove', (e) => this.handleMovieInteractionMove(e));
            window.addEventListener('mouseup', (e) => this.handleMovieInteractionEnd(e));
            this.dom.canvasPanel.addEventListener('mouseleave', () => { if (!this.state.movieInteraction.active) { this.dom.movieCanvas.style.cursor = 'default'; this.dom.pasteboardOverlayCanvas.style.cursor = 'default'; } this.state.eraseBrushPos = {x: -1000, y: -1000}; if(this.state.eraserMode !== 'none') { this.drawControlsOverlay(); } });
            window.addEventListener('keydown', (e) => this.handleKeyDown(e));
            window.addEventListener('beforeunload', () => this.saveCurrentWork());
            this.dom.canvasPanel.addEventListener('dragover', e => { e.preventDefault(); this.dom.canvasPanel.classList.add('drag-over') });
            this.dom.canvasPanel.addEventListener('dragleave', () => this.dom.canvasPanel.classList.remove('drag-over'));
            this.dom.canvasPanel.addEventListener('drop', e => { e.preventDefault(); this.dom.canvasPanel.classList.remove('drag-over'); const file = e.dataTransfer.files[0]; if (file) { const intendedUse = this.state.canvasState.backgroundElement ? 'asset' : 'background'; this.handleFileUpload(file, intendedUse); } });
            window.addEventListener('paste', e => { const items = e.clipboardData?.items; if (!items) return; let imageFile = null; for (let i = 0; i < items.length; i++) { if (items[i].type.indexOf('image') !== -1) { imageFile = items[i].getAsFile(); break; } } if (imageFile) { e.preventDefault(); const intendedUse = this.dom.addLayerOverlay.classList.contains('visible') || this.state.canvasState.backgroundElement ? 'asset' : 'background'; this.handleFileUpload(imageFile, intendedUse); } });
            this.dom.visualsTabAssetBtn.addEventListener('click', () => { this.switchVisualsTab('asset'); if (!this.getActiveLayer() || this.getActiveLayer().type !== 'image') { this.toast('Select an image layer to enable asset editing.', 3000); } });
            this.dom.visualsTabBackgroundBtn.addEventListener('click', () => this.switchVisualsTab('background'));
            this.dom.fontSelectTrigger.addEventListener('click', (e) => { e.stopPropagation(); if (this.dom.customFontSelect.classList.contains('open')) { this.closeFontDropdown(); } else { this.openFontDropdown(); } });
            this.dom.fontSelectDropdown.addEventListener('mouseleave', () => this.handleFontHoverEnd());
            this.dom.eraseBtn.addEventListener('click', () => this.setEraserMode('erase'));
            this.dom.uneraseBtn.addEventListener('click', () => this.setEraserMode('unerase'));

            // The generic loop is now only for things not yet refactored (e.g., eraser sliders)
            document.querySelectorAll('.control-panel input, .control-panel textarea, .control-panel select').forEach(input => {
                const isRefactored = [ 'asset-opacity', 'asset-brightness', 'asset-saturation', 'shadow-enable', 'shadow-color', 'shadow-blur', 'shadow-offset-x', 'shadow-offset-y', 'asset-edge-enable', 'asset-edge-color', 'asset-edge-width', 'bg-brightness', 'bg-saturation', 'text-content', 'text-size', 'text-color', 'text-edge-color', 'text-edge-width', 'text-shadow-enable', 'text-shadow-color', 'text-shadow-blur', 'text-shadow-offset-x', 'text-shadow-offset-y' ].includes(input.id);
                if (!isRefactored) {
                    const action = () => { if (input.type === 'range') this.updateSliderFill(input); };
                    input.addEventListener('input', action);
                }
            });

            // =====================================================================
            // PHASE 1 - Refactored Event Listeners Block
            // =====================================================================
            
            const setupRefactoredSlider = (slider, propertyName) => {
                slider.addEventListener('input', (e) => {
                    const activeLayer = this.getActiveLayer();
                    if (!activeLayer) return;
                    this.dispatch({ type: 'LAYER_PROPERTY_CHANGED', payload: { layerId: activeLayer.id, property: propertyName, value: parseFloat(e.target.value) } });
                    this.updateSliderFill(e.target);
                });
                slider.addEventListener('change', () => this.saveStateDebounced());
            };
            
            const setupShadowControlListener = (elementId, propertyName, valueExtractor) => {
                const element = document.getElementById(elementId);
                if (!element) return;
                element.addEventListener('input', (e) => {
                    const activeLayer = this.getActiveLayer();
                    if (!activeLayer) return;
                    const value = valueExtractor(e.target);
                    this.dispatch({ type: 'LAYER_SHADOW_CHANGED', payload: { layerId: activeLayer.id, property: propertyName, value: value } });
                    if (elementId === 'shadow-enable') { document.getElementById('shadow-controls').classList.toggle('disabled', !value); }
                    if (e.target.type === 'range') { this.updateSliderFill(e.target); }
                });
                element.addEventListener('change', () => this.saveStateDebounced());
            };
            
            const setupBorderControlListener = (elementId, propertyName, valueExtractor) => {
                const element = document.getElementById(elementId);
                if (!element) return;
                element.addEventListener('input', (e) => {
                    const activeLayer = this.getActiveLayer();
                    if (!activeLayer) return;
                    const value = valueExtractor(e.target);
                    this.dispatch({ type: 'LAYER_BORDER_CHANGED', payload: { layerId: activeLayer.id, property: propertyName, value: value } });
                    if (elementId === 'asset-edge-enable') { document.getElementById('asset-edge-controls').classList.toggle('disabled', !value); }
                    if (e.target.type === 'range') { this.updateSliderFill(e.target); }
                });
                element.addEventListener('change', () => this.saveStateDebounced());
            };
            
            const setupBgFilterSlider = (slider, propertyName) => {
                slider.addEventListener('input', (e) => {
                    this.dispatch({ type: 'BACKGROUND_FILTER_CHANGED', payload: { property: propertyName, value: parseFloat(e.target.value) } });
                    this.updateSliderFill(e.target);
                });
                slider.addEventListener('change', () => this.saveStateDebounced());
            };
            
            const setupTextPropertyListener = (element, propertyName, valueExtractor) => {
                element.addEventListener('input', (e) => {
                    const activeLayer = this.getActiveLayer();
                    if (!activeLayer || activeLayer.type !== 'text') return;
                    this.dispatch({ type: 'LAYER_PROPERTY_CHANGED', payload: { layerId: activeLayer.id, property: propertyName, value: valueExtractor(e.target) } });
                    if (e.target.type === 'range') { this.updateSliderFill(e.target); }
                });
                element.addEventListener('change', () => this.saveStateDebounced());
            };
            
            const setupTextShadowControlListener = (elementId, propertyName, valueExtractor) => {
                const element = document.getElementById(elementId);
                if (!element) return;
                element.addEventListener('input', (e) => {
                    const activeLayer = this.getActiveLayer();
                    if (!activeLayer || activeLayer.type !== 'text') return;
                    const value = valueExtractor(e.target);
                    this.dispatch({ type: 'LAYER_SHADOW_CHANGED', payload: { layerId: activeLayer.id, property: propertyName, value: value } });
                    if (elementId === 'text-shadow-enable') { document.getElementById('text-shadow-controls').classList.toggle('disabled', !value); }
                    if (e.target.type === 'range') { this.updateSliderFill(e.target); }
                });
                element.addEventListener('change', () => this.saveStateDebounced());
            };

            setupRefactoredSlider(this.dom.assetOpacitySlider, 'opacity');
            setupRefactoredSlider(this.dom.assetBrightnessSlider, 'brightness');
            setupRefactoredSlider(this.dom.assetSaturationSlider, 'saturation');
            setupShadowControlListener('shadow-enable', 'enabled', target => target.checked);
            setupShadowControlListener('shadow-color', 'color', target => target.value);
            setupShadowControlListener('shadow-blur', 'blur', target => parseFloat(target.value));
            setupShadowControlListener('shadow-offset-x', 'offsetX', target => parseFloat(target.value));
            setupShadowControlListener('shadow-offset-y', 'offsetY', target => parseFloat(target.value));
            setupBorderControlListener('asset-edge-enable', 'enabled', target => target.checked);
            setupBorderControlListener('asset-edge-color', 'color', target => target.value);
            setupBorderControlListener('asset-edge-width', 'width', target => parseFloat(target.value));
            setupBgFilterSlider(this.dom.bgBrightnessSlider, 'bgBrightness');
            setupBgFilterSlider(this.dom.bgSaturationSlider, 'bgSaturation');
            this.dom.textContentInput.addEventListener('input', (e) => {
                const activeLayer = this.getActiveLayer();
                if (!activeLayer || activeLayer.type !== 'text') return;
                this.dispatch({ type: 'LAYER_PROPERTY_CHANGED', payload: { layerId: activeLayer.id, property: 'text', value: e.target.value } });
                this.renderTextLayerPalette();
            });
            this.dom.textContentInput.addEventListener('change', () => this.saveStateDebounced());
            setupTextPropertyListener(this.dom.textSizeSlider, 'fontSize', target => parseFloat(target.value));
            setupTextPropertyListener(this.dom.textColorInput, 'color', target => target.value);
            setupTextPropertyListener(this.dom.textEdgeColorInput, 'strokeColor', target => target.value);
            setupTextPropertyListener(this.dom.textEdgeWidthSlider, 'strokeWidth', target => parseFloat(target.value));
            setupTextShadowControlListener('text-shadow-enable', 'enabled', target => target.checked);
            setupTextShadowControlListener('text-shadow-color', 'color', target => target.value);
            setupTextShadowControlListener('text-shadow-blur', 'blur', target => parseFloat(target.value));
            setupTextShadowControlListener('text-shadow-offset-x', 'offsetX', target => parseFloat(target.value));
            setupTextShadowControlListener('text-shadow-offset-y', 'offsetY', target => parseFloat(target.value));

            // --- Collaboration Listeners ---
            this.dom.startSessionBtn.addEventListener('click', () => { this.collaborationManager.startSession(); });
            this.dom.shareSessionCloseBtn.addEventListener('click', () => { this.collaborationManager.hideShareLinkModal(); });
            
            // --- MODIFIED: Implements Step 4 ---
            this.dom.copyShareLinkBtn.addEventListener('click', () => {
                const btn = this.dom.copyShareLinkBtn;
                const originalText = btn.textContent;
                
                navigator.clipboard.writeText(this.dom.shareLinkInput.value).then(() => {
                    btn.textContent = 'Copied!';
                    setTimeout(() => {
                        btn.textContent = originalText;
                    }, 2000); // Revert text after 2 seconds
                }).catch(err => {
                    console.error('Failed to copy link: ', err);
                    this.toast("Could not copy link.", 3000);
                });
            });

            this.dom.shareSessionOverlay.addEventListener('click', (e) => { if (e.target === this.dom.shareSessionOverlay) { this.collaborationManager.hideShareLinkModal(); } });
            
            // =====================================================================

            const textMoveForwardBtn = document.getElementById('text-move-forward'), textMoveBackBtn = document.getElementById('text-move-back');
            if (textMoveForwardBtn) textMoveForwardBtn.addEventListener('click', () => { const l = this.getActiveLayer(); if (l?.type === 'text') { this.dispatch({ type: 'LAYER_REORDERED', payload: { layerId: l.id, delta: -1 } }); this.renderLayerPalette(); this.renderTextLayerPalette(); this.updateTextOrderButtonsState(); this.drawFrame(); this.saveState(); } });
            if (textMoveBackBtn) textMoveBackBtn.addEventListener('click', () => { const l = this.getActiveLayer(); if (l?.type === 'text') { this.dispatch({ type: 'LAYER_REORDERED', payload: { layerId: l.id, delta: 1 } }); this.renderLayerPalette(); this.renderTextLayerPalette(); this.updateTextOrderButtonsState(); this.drawFrame(); this.saveState(); } });
            this.dom.viewAllLocalAssetsBtn.addEventListener('click', () => { this.populateProjectLibraryPopup(); const lastTab = localStorage.getItem('ims-last-library-tab') || 'assets'; this.setLocalFolderTab(lastTab); this.dom.projectLibraryPopupOverlay.classList.add('visible'); });
            this.dom.projectLibraryPopupCloseBtn.addEventListener('click', () => this.dom.projectLibraryPopupOverlay.classList.remove('visible'));
            this.dom.projectLibraryPopupOverlay.addEventListener('click', (e) => { if (e.target === this.dom.projectLibraryPopupOverlay) this.dom.projectLibraryPopupOverlay.classList.remove('visible'); });
            this.dom.libraryTabProjectsBtn.addEventListener('click', () => this.switchAndSaveLibraryTab('projects'));
            this.dom.libraryTabAssetsBtn.addEventListener('click', () => this.switchAndSaveLibraryTab('assets'));
            this.dom.libraryTabBackgroundsBtn.addEventListener('click', () => this.switchAndSaveLibraryTab('backgrounds'));
            this.dom.libraryTabFavoritesBtn.addEventListener('click', () => this.switchAndSaveLibraryTab('favorites'));
            this.dom.toggleViewBtn.addEventListener('click', () => this.toggleCanvasZoom());
            this.dom.confirmSaveContinueBtn.addEventListener('click', async () => {
                this.dom.saveChangesOverlay.classList.remove('visible');
                await this.saveProjectToLibrary();
                if (this.state.pendingProjectId) { await this._actuallyLoadProject(this.state.pendingProjectId); this.state.pendingProjectId = null; }
            });
            this.dom.confirmDiscardContinueBtn.addEventListener('click', async () => {
                this.dom.saveChangesOverlay.classList.remove('visible');
                if (this.state.pendingProjectId) { await this._actuallyLoadProject(this.state.pendingProjectId); this.state.pendingProjectId = null; }
            });
            this.dom.openFontPreviewBtn.addEventListener('click', () => this.openFontPreviewModal());
            this.dom.fontPreviewCloseBtn.addEventListener('click', () => this.closeFontPreviewModal());
            this.dom.fontPreviewOverlay.addEventListener('click', (e) => {
                if (e.target === this.dom.fontPreviewOverlay) { this.closeFontPreviewModal(); }
            });
            window.addEventListener('click', (e) => {
                if (this.dom.shortcutsDropdown.classList.contains('visible') && !this.dom.shortcutsDropdown.contains(e.target) && !this.dom.shortcutsBtn.contains(e.target)) { this.dom.shortcutsDropdown.classList.remove('visible'); }
                if (this.dom.customFontSelect.classList.contains('open') && !this.dom.customFontSelect.contains(e.target)) { this.closeFontDropdown(); }
            });
            const canvasResizeObserver = new ResizeObserver(() => { this.resizeCanvas(); this.drawFrame(); });
            canvasResizeObserver.observe(this.dom.canvasPanel);
        },
        
        getActiveLayer() { 
            return this.state.canvasState.layers.find(l => l.id === this.state.activeLayerId);
        },

        async init() {
            // --- Step 1: Cache ALL DOM elements first ---
            this.dom.loadingOverlay = document.getElementById('loading-overlay');
            if (this.dom.loadingOverlay) { this.dom.loadingMessage = this.dom.loadingOverlay.querySelector('h1'); }
            this.dom.toastEl = document.getElementById('mg-toast');
            this.dom.addLayerOverlay = document.getElementById('mg-asset-library-overlay');
            this.dom.assetPalette = document.getElementById('mg-asset-palette');
            this.dom.addLayerFileInput = document.getElementById('mg-asset-picker-file');
            this.dom.canvasPanel = document.getElementById('canvas-panel');
            this.dom.canvasPlaceholder = document.getElementById('canvas-placeholder');
            this.dom.controlsOverlayCanvas = document.getElementById('mg-controls-overlay-canvas');
            this.dom.initialBackgroundInput = document.getElementById('initial-background-input');
            this.dom.layerInstructions = document.getElementById('layer-instructions');
            this.dom.movieCanvas = document.getElementById('mg-movie-canvas');
            this.dom.downloadImageBtn = document.getElementById('mg-download-image-btn');
            this.dom.saveProjectBtn = document.getElementById('mg-save-project-btn');
            this.dom.clearCanvasBtn = document.getElementById('mg-clear-canvas-btn');
            this.dom.confirmationOverlay = document.getElementById('mg-confirmation-overlay');
            this.dom.confirmationText = document.getElementById('mg-confirmation-text');
            this.dom.confirmYesBtn = document.getElementById('mg-confirm-yes-btn');
            this.dom.confirmNoBtn = document.getElementById('mg-confirm-no-btn');
            this.dom.shortcutsBtn = document.getElementById('shortcuts-btn');
            this.dom.shortcutsDropdown = document.getElementById('shortcuts-dropdown');
            this.dom.visualsBtn = document.getElementById('visuals-btn');
            this.dom.textBtn = document.getElementById('text-btn');
            this.dom.eraseToolBtn = document.getElementById('erase-tool-btn');
            this.dom.aiToolsBtn = document.getElementById('ai-tools-btn');
            this.dom.visualsPanel = document.getElementById('visuals-panel');
            this.dom.textPanel = document.getElementById('text-panel');
            this.dom.eraserPanel = document.getElementById('eraser-panel');
            this.dom.assetVisualsControls = document.getElementById('asset-visuals-controls');
            this.dom.assetOpacitySlider = document.getElementById('asset-opacity');
            this.dom.assetBrightnessSlider = document.getElementById('asset-brightness');
            this.dom.assetSaturationSlider = document.getElementById('asset-saturation');
            this.dom.bgBrightnessSlider = document.getElementById('bg-brightness');
            this.dom.bgSaturationSlider = document.getElementById('bg-saturation');
            this.dom.textVisualsControls = document.getElementById('text-visuals-controls');
            this.dom.textContentInput = document.getElementById('text-content');
            this.dom.textSizeSlider = document.getElementById('text-size');
            this.dom.textColorInput = document.getElementById('text-color');
            this.dom.textEdgeColorInput = document.getElementById('text-edge-color');
            this.dom.textEdgeWidthSlider = document.getElementById('text-edge-width');
            this.dom.addNewTextLayerBtn = document.getElementById('add-new-text-layer-btn');
            this.dom.textLayerPalette = document.getElementById('text-layer-palette');
            this.dom.toggleViewBtn = document.getElementById('toggle-view-btn');
            this.dom.eraseBtn = document.getElementById('erase-btn');
            this.dom.uneraseBtn = document.getElementById('unerase-btn');
            this.dom.eraserControlsWrapper = document.getElementById('eraser-controls-wrapper');
            this.dom.eraserSize = document.getElementById('eraser-size');
            this.dom.eraserStrength = document.getElementById('eraser-strength');
            this.dom.assetsFolderFieldset = document.getElementById('assets-folder-fieldset');
            this.dom.localAssetPalette = document.getElementById('mg-local-asset-palette');
            this.dom.localBackgroundPalette = document.getElementById('mg-local-background-palette');
            this.dom.viewAllLocalAssetsBtn = document.getElementById('mg-view-all-local-assets-btn');
            this.dom.projectLibraryPopupOverlay = document.getElementById('project-library-popup-overlay');
            this.dom.projectLibraryGridProjects = document.getElementById('project-library-grid-projects');
            this.dom.projectLibraryGridAssets = document.getElementById('project-library-grid-assets');
            this.dom.projectLibraryGridBackgrounds = document.getElementById('project-library-grid-backgrounds');
            this.dom.projectLibraryGridFavorites = document.getElementById('project-library-grid-favorites');
            this.dom.libraryTabProjectsBtn = document.getElementById('library-tab-projects');
            this.dom.libraryTabAssetsBtn = document.getElementById('library-tab-assets');
            this.dom.libraryTabBackgroundsBtn = document.getElementById('library-tab-backgrounds');
            this.dom.libraryTabFavoritesBtn = document.getElementById('library-tab-favorites');
            this.dom.projectLibraryPopupCloseBtn = document.getElementById('project-library-popup-close');
            this.dom.visualsTabAssetBtn = document.getElementById('visuals-tab-asset');
            this.dom.visualsTabBackgroundBtn = document.getElementById('visuals-tab-background');
            this.dom.assetTabPanel = document.getElementById('asset-tab-panel');
            this.dom.backgroundTabPanel = document.getElementById('background-tab-panel');
            this.dom.customFontSelect = document.getElementById('custom-font-select');
            this.dom.fontSelectTrigger = document.getElementById('font-select-trigger');
            this.dom.fontSelectDropdown = document.getElementById('font-select-dropdown');
            this.dom.fontSelectList = document.getElementById('font-select-list');
            this.dom.themePopupOverlay = document.getElementById('theme-popup-overlay');
            this.dom.themePopupContent = document.getElementById('theme-popup-content');
            this.dom.themeList = document.getElementById('theme-list');
            this.dom.themeSelectLink = document.getElementById('theme-select-link');
            this.dom.currentThemeNameSpan = document.getElementById('current-theme-name');
            this.dom.pasteboardOverlayCanvas = document.getElementById('mg-pasteboard-overlay-canvas');
            this.dom.saveChangesOverlay = document.getElementById('save-changes-overlay');
            this.dom.confirmSaveContinueBtn = document.getElementById('confirm-save-continue-btn');
            this.dom.confirmDiscardContinueBtn = document.getElementById('confirm-discard-continue-btn');
            this.dom.confirmCancelLoadBtn = document.getElementById('confirm-cancel-load-btn');
            this.dom.openFontPreviewBtn = document.getElementById('open-font-preview-btn');
            this.dom.fontPreviewOverlay = document.getElementById('font-preview-overlay');
            this.dom.fontPreviewGrid = document.getElementById('font-preview-grid');
            this.dom.fontPreviewCloseBtn = document.getElementById('font-preview-close-btn');
            this.dom.startSessionBtn = document.getElementById('mg-start-session-btn');
            this.dom.shareSessionOverlay = document.getElementById('share-session-overlay');
            this.dom.shareSessionCloseBtn = document.getElementById('share-session-close-btn');
            this.dom.shareLinkInput = document.getElementById('share-link-input');
            this.dom.copyShareLinkBtn = document.getElementById('copy-share-link-btn');
            
            // --- Step 2: Initialize all objects and contexts that depend on the DOM ---
            this.dom.movieCtx = this.dom.movieCanvas.getContext('2d');
            this.dom.controlsCtx = this.dom.controlsOverlayCanvas.getContext('2d');
            this.dom.pasteboardCtx = this.dom.pasteboardOverlayCanvas.getContext('2d');
            this.saveStateDebounced = this.debounce(this.saveState, this.config.DEBOUNCE_DELAY);
            this.config.themes = window.themes;
            this.panelManager.init(this); 
            this.collaborationManager.init(this);
            this.collaborationManager.checkForSessionInUrl();
            this.panelManager.init(this); 
            this.collaborationManager.init(this);
            
            // ADD THIS LINE
            this.throttledBroadcast = this.throttle((action) => this.collaborationManager.broadcastAction(action), 50); // 50ms = 20 updates per second

            this.collaborationManager.checkForSessionInUrl();

            // --- Step 3: Run the rest of the startup logic ---
            // --- WORKER INITIALIZATION BLOCK UPDATED HERE ---
            try {
                this.state.converterWorker = new Worker('webp-converter.js');
                this.state.converterWorker.onmessage = async (event) => {
                    const { status, blob, layerId, originalHash, wasOptimized, kind, error } = event.data;
                    if (status === 'error') {
                        this.toast(`Could not optimize asset: ${error}`, 3000);
                        return;
                    }

                    await this.saveAssetToLibrary({ blob, mime: blob.type, hash: originalHash, kind });

                    if (!layerId) return;

                    const layer = this.state.canvasState.layers.find(l => l.id === layerId);
                    if (!layer) {
                        URL.revokeObjectURL(URL.createObjectURL(blob));
                        return;
                    }

                    // Create all the new assets first
                    const newImage = new Image();
                    const newImageURL = URL.createObjectURL(blob);
                    newImage.src = newImageURL;
                    await newImage.decode();

                    const newProxyCanvas = document.createElement('canvas');
                    newProxyCanvas.width = newImage.naturalWidth;
                    newProxyCanvas.height = newImage.naturalHeight;
                    const newProxyCtx = newProxyCanvas.getContext('2d', { willReadFrequently: true });
                    newProxyCtx.drawImage(newImage, 0, 0);
                    const newContentFrame = this.calculateContentBounds(newProxyCanvas);

                    // Dispatch the action with a payload of all the new data
                    this.dispatch({
                        type: 'LAYER_OPTIMIZATION_COMPLETE',
                        payload: {
                            layerId: layerId,
                            newAsset: newImage,
                            newSrc: newImageURL,
                            newProxyCanvas: newProxyCanvas,
                            newProxyCtx: newProxyCtx,
                            newContentFrame: newContentFrame,
                            wasOptimized: wasOptimized
                        }
                    });
                };
             } catch(e) { 
                console.warn("Could not initialize the webp-converter worker. Asset optimization will be disabled.", e); 
            }
            const savedThemeName = localStorage.getItem('selectedTheme') || 'Midnight';
            this.applyTheme(savedThemeName);
            this.state.originalTheme = savedThemeName;
            if (this.dom.currentThemeNameSpan) { this.dom.currentThemeNameSpan.textContent = savedThemeName; }
            this.config.availableFonts.forEach(font => this.config.fontValueToNameMap.set(font.value, font.name));
            
            const minDisplayTime = new Promise(resolve => setTimeout(resolve, 1500)); 
            const setupPromise = (async () => {
                this.injectNonCriticalStyles();
                this.populateThemeList();
                this.populateCustomFontSelector();
                this.addBgUI();
                await this.dedupeExistingAssetsByHashKeepNewest();

                const isJoiningSession = window.location.hash.startsWith('#room=');
                if (!isJoiningSession) {
                    await this.restoreCurrentWork();
                }

                this.updateControlsState();
                this.updateEditPanelsUI();
                this.setupEventListeners();
                this.drawFrame();
                this.state.lastSavedStateHash = this.generateCanvasStateHash();
            })();
        
            try { await Promise.all([minDisplayTime, setupPromise]); } 
            catch (error) { console.error("Initialization failed, but proceeding to the app anyway.", error); this.toast("Could not restore a previous session.", 4000); } 
            finally { this.hideLoadingScreen(); }
        }

    };

    

    document.addEventListener('DOMContentLoaded', () => {
        ImageMakerStudio.init();
    });
</script>
</body>
</html>